[{"path":"index.html","id":"prÃ©sentation-de-la-formation","chapter":"PrÃ©sentation de la formation","heading":"PrÃ©sentation de la formation","text":"Le principal de cette formation est de vous donner des outils pour\nfaciliter le dÃ©veloppement de code (performant) avec . Lâ€™aspect â€œperformanceâ€\narrivera dans un deuxiÃ¨me temps, et les premiers outils prÃ©sentÃ©s sont\nÃ©galement trÃ¨s utiles dans des situations ne faisant pas intervenir de temps\nde calculs importants.Nous allons centrer la prÃ©sentation de ces outils de dÃ©veloppement autour\nde la notion de package. Vous connaissez dÃ©jÃ  cette notion, car vous avez\ndÃ©jÃ  installer des packages depuis le CRAN par exemple. Vous savez Ã©galement\nque câ€™est le moyen le plus standard dans  pour\npartager et mettre Ã  disposition du code.\nNous allons vous montrer que le package est Ã©galement un excellent outil pour\ndÃ©velopper le code.Nous allons adopter le plan suivant :Build R package useful tool code developmentLeverage git tracking changes, GitHub sharing code, collaborative development, automating tests package broadcast companion websiteLeverage git tracking changes, GitHub sharing code, collaborative development, automating tests package broadcast companion websiteConstruire un package  comme outils de dÃ©veloppement de codeConstruire un package  comme outils de dÃ©veloppement de codeUtiliser git pour tracer les changements, et GitHub pour partager son code, le dÃ©veloppement collaboratif, automatiser les tests dans un package et diffuser un site web dâ€™accompagnementUtiliser git pour tracer les changements, et GitHub pour partager son code, le dÃ©veloppement collaboratif, automatiser les tests dans un package et diffuser un site web dâ€™accompagnementMesurer le temps de calculMesurer le temps de calculProfiler le codeProfiler le codeUtiliser Rcpp pour optimiser ce qui doit lâ€™ÃªtreUtiliser Rcpp pour optimiser ce qui doit lâ€™ÃªtreParallÃ©liser facilement le codeParallÃ©liser facilement le code","code":""},{"path":"index.html","id":"logiciels-et-librairies-nÃ©cessaires-Ã -la-formation","chapter":"PrÃ©sentation de la formation","heading":"Logiciels et librairies nÃ©cessaires Ã  la formation","text":"Afin de suivre cette formation, il est nÃ©cessaire de disposer des logiciels suivants :la derniÃ¨re version de  (https://cloud.r-project.org/)la derniÃ¨re version de  (https://cloud.r-project.org/)la derniÃ¨re version de RStudio (https://posit.co/download/rstudio-desktop/#download)la derniÃ¨re version de RStudio (https://posit.co/download/rstudio-desktop/#download)un compilateur C++ (tel que gcc ou clang - natif sous les systÃ¨me UNIX,\npour les utilisateurs Windows nous recommandons lâ€™installation de\nRtools, pour les\nutilisateurs Mac il peut Ãªtre nÃ©cessaire dâ€™installer les outils de\ndÃ©veloppement Apple comme indiquÃ©\nici)un compilateur C++ (tel que gcc ou clang - natif sous les systÃ¨me UNIX,\npour les utilisateurs Windows nous recommandons lâ€™installation de\nRtools, pour les\nutilisateurs Mac il peut Ãªtre nÃ©cessaire dâ€™installer les outils de\ndÃ©veloppement Apple comme indiquÃ©\nici)les packages  suivants : devtools, future.apply, itertools, microbenchmark, mvtnorm, profvis, Rcpp, RcppArmadillo, roxygen2, testthat, usethisles packages  suivants : devtools, future.apply, itertools, microbenchmark, mvtnorm, profvis, Rcpp, RcppArmadillo, roxygen2, testthat, usethisle logiciel gitle logiciel gitle client GitHub Desktople client GitHub Desktop","code":""},{"path":"index.html","id":"prÃ©-requis","chapter":"PrÃ©sentation de la formation","heading":"PrÃ©-requis","text":"Afin de pouvoir suivre cette formation correctement vous devez Ãªtre Ã  lâ€™aise avec les aspects suivants :la programation avec  dans lâ€™environnement de dÃ©veloppement RStudioÃ©criture de fonctions en structure de contrÃ´le, en particulier les boucles forle calcul de la densitÃ© dâ€™une loi normale multivariÃ©e","code":""},{"path":"construire-un-package.html","id":"construire-un-package","chapter":"Chapitre 1 Construire un package ","heading":"Chapitre 1 Construire un package ","text":"Nous prÃ©sentons ici comment construire un package efficacement Ã  lâ€™aide dâ€™outils\ngraphiques prÃ©sents dans RStudio et du package devtools.Le support de rÃ©fÃ©rence sur ce sujet est le livre\nR packages1 dâ€™Hadley Wickham & Jennifer Bryan, disponible en ligne.","code":""},{"path":"construire-un-package.html","id":"initialiser-un-package","chapter":"Chapitre 1 Construire un package ","heading":"1.1 Initialiser un package","text":"Une maniÃ¨re simple, et intÃ©grÃ©e Ã  RStudio, pour initialiser un package est dâ€™executer les Ã©tapes suivantes :ğŸ‘‰ Ã€ vous de jouer (dÃ©jÃ )!crÃ©er un nouveau projet (menu dÃ©roulant en haut Ã  gauche dans RStudio)crÃ©er un nouveau projet (menu dÃ©roulant en haut Ã  gauche dans RStudio)choisir â€œNew Directoryâ€choisir â€œNew Directoryâ€choisir â€œR package using devtoolsâ€ (sâ€™il nâ€™est pas disponible câ€™est que le package devtools nâ€™est pas installer et dans ce cas peut alors choisir â€œR packageâ€ â€“ la diffÃ©rence Ã©tant quâ€™avec â€œR packageâ€, il faudra supprimer des fichiers crÃ©Ã©s automatiquement mais inutiles)choisir â€œR package using devtoolsâ€ (sâ€™il nâ€™est pas disponible câ€™est que le package devtools nâ€™est pas installer et dans ce cas peut alors choisir â€œR packageâ€ â€“ la diffÃ©rence Ã©tant quâ€™avec â€œR packageâ€, il faudra supprimer des fichiers crÃ©Ã©s automatiquement mais inutiles)donner un nom au package, par exemple mypkgr.donner un nom au package, par exemple mypkgr.rÃ©cupÃ¨re alors la structure minimale pour un package , Ã  savoir :un fichier DESCRIPTION dont les parties Title, Version, Authors@R et\nDescription sont Ã  Ã©diter (dâ€™autres parties pourront Ãªtre Ã©diter voire\nmÃªme ajouter de maniÃ¨re automatique, comme nous le verrons plus loin)un fichier DESCRIPTION dont les parties Title, Version, Authors@R et\nDescription sont Ã  Ã©diter (dâ€™autres parties pourront Ãªtre Ã©diter voire\nmÃªme ajouter de maniÃ¨re automatique, comme nous le verrons plus loin)un fichier NAMESPACE qui sera Ã©ditÃ© automatiquement ultÃ©rieurementun fichier NAMESPACE qui sera Ã©ditÃ© automatiquement ultÃ©rieurementun dossier R dans lequel va ajouter des fichiers de scripts un dossier R dans lequel va ajouter des fichiers de scripts devtools ajoute Ã©galement trois fichiers facultatifs :.gitignore, relatif Ã  git, outils de contrÃ´le de version que nous verrons en dÃ©tails\ndans la partie sur GitHub.gitignore, relatif Ã  git, outils de contrÃ´le de version que nous verrons en dÃ©tails\ndans la partie sur GitHubmypkgr.Rproj qui est un fichier spÃ©cifique de Rstudio, et permet de dÃ©finir\nles caractÃ©ristiques et prÃ©fÃ©rences du projet que nous venons de crÃ©ermypkgr.Rproj qui est un fichier spÃ©cifique de Rstudio, et permet de dÃ©finir\nles caractÃ©ristiques et prÃ©fÃ©rences du projet que nous venons de crÃ©er.Rbuildignore qui permet dâ€™ignorer certains fichiers au moment oÃ¹ \nconstruira le package un peu plus loin (par exemple, le fichier mypkgr.Rproj\nne doit pas Ãªtre inclus dans le package).Rbuildignore qui permet dâ€™ignorer certains fichiers au moment oÃ¹ \nconstruira le package un peu plus loin (par exemple, le fichier mypkgr.Rproj\nne doit pas Ãªtre inclus dans le package)","code":""},{"path":"construire-un-package.html","id":"ajouter-une-fonction-exemple-fil-rouge","chapter":"Chapitre 1 Construire un package ","heading":"1.2 Ajouter une fonction : exemple fil rouge","text":"Nous vous proposons de coder la fonction suivante, que nous reprendrons tout au\nlong de la formation :Nous souhaitons calculer la valeur de la densitÃ© dâ€™une loi normale multivariÃ©e\nsur \\(\\mathbb{R}^p\\) en \\(n\\) points. Notre fonction doit pouvoir sâ€™appliquer pour\nnâ€™importe quelle loi normale multivariÃ©e (vecteur de moyennes \\(\\boldsymbol \\mu\\) dans\n\\(\\mathbb{R}^p\\) et matrice de variance-covariance \\(\\boldsymbol\\Sigma\\) dâ€™ordre de \\(p\\) quelconques),\net souhaite pouvoir calculer toutes les valeurs de la densitÃ© Ã©valuÃ©es\nsur les \\(n\\) points \\(\\boldsymbol \\mathbf{x}\\) en un seul appel de la fonction.Pour rappel, la fonction de densitÃ© dâ€™une loi normale multivariÃ©e sâ€™Ã©crit :\n\\[\\displaystyle (2\\pi )^{-p/2}\\det({\\boldsymbol {\\Sigma }})^{-1/2}\\,\\exp \\left(-{\\frac {1}{2}}(\\mathbf {x} -{\\boldsymbol {\\mu }})^{\\mathsf {T}}{\\boldsymbol {\\Sigma }}^{-1}(\\mathbf {x} -{\\boldsymbol {\\mu }})\\right)\\]Vous devez donc crÃ©er une fonction mvnpdf() dans un fichier nommÃ© mvnpdf.R\ndans le dossier  du package, qui :prend en arguments :\nx une matrice, Ã  \\(n\\) colonnes (les observations) et \\(p\\) lignes\nmean un vecteur de moyennes\nvarcovM une matrice de variance-covariance\nLog un paramÃ¨tre logique valant TRUE par dÃ©faut\nprend en arguments :x une matrice, Ã  \\(n\\) colonnes (les observations) et \\(p\\) lignesx une matrice, Ã  \\(n\\) colonnes (les observations) et \\(p\\) lignesmean un vecteur de moyennesmean un vecteur de moyennesvarcovM une matrice de variance-covariancevarcovM une matrice de variance-covarianceLog un paramÃ¨tre logique valant TRUE par dÃ©fautLog un paramÃ¨tre logique valant TRUE par dÃ©fautrenvoie une liste contenant la matrice x ainsi quâ€™un vecteur des images\ndes points de x par la fonction de densitÃ© de la variable alÃ©atoire de loi\nnormale multivariÃ©e considÃ©rÃ©e.renvoie une liste contenant la matrice x ainsi quâ€™un vecteur des images\ndes points de x par la fonction de densitÃ© de la variable alÃ©atoire de loi\nnormale multivariÃ©e considÃ©rÃ©e.ğŸ‘‰ Ã€ vous de jouer !Voici une proposition de fonction que vous pouvez tÃ©lÃ©charger\nici. âš ï¸ ATTENTION ! Si vous cliquez trop vite sur le lien ci-dessous, cela invalidera votre participation Ã  la formation !Pour des conseils lors de la rÃ©daction de code, voir le chapitre\nR code dans R packages (2023) de Wickham & Bryan2.","code":""},{"path":"construire-un-package.html","id":"documenter-une-fonction","chapter":"Chapitre 1 Construire un package ","heading":"1.3 Documenter une fonction","text":"Il est important de bien documenter votre code. Tout projet au moins 2\ndÃ©veloppeurs :vousvousvous dans 6 moisvous dans 6 moisPar Ã©gard Ã  votre â€œfutur vousâ€, soyez sympas et prenez le temps de documenter\nvotre code ğŸ˜‰ !Nous vous conseillons vivement dâ€™utiliser le package roxygen2 pour documenter\nvos packages. Lâ€™avantage principal Ã©tant dâ€™avoir lâ€™aide dâ€™une fonction dans\nle mÃªme fichier que le code dÃ©finissant cette fonction.ğŸ‘‰ Ã€ vous de jouer !Commencer par insÃ©rer le squelette de lâ€™aide grÃ¢ce Ã  â€œInsert Roxygen\nSkeletonâ€ situÃ© dans le menu â€œCodeâ€ ou le sous-menu Baguette magique dans\nla fenÃªtre de script.Commencer par insÃ©rer le squelette de lâ€™aide grÃ¢ce Ã  â€œInsert Roxygen\nSkeletonâ€ situÃ© dans le menu â€œCodeâ€ ou le sous-menu Baguette magique dans\nla fenÃªtre de script.ComplÃ©ter la documentation en renseignant :\nle titre de la fonction (premiÃ¨re ligne)\nla description de ce que fait la fonction (deuxiÃ¨me paragraphe)\nsi vous renseignez un troisiÃ¨me paragraphe, cette partie ira dans la section â€œDetailsâ€ de la page dâ€™aide\nla signification des paramÃ¨tres\nla sortie, aprÃ¨s la balise @return\nComplÃ©ter la documentation en renseignant :le titre de la fonction (premiÃ¨re ligne)le titre de la fonction (premiÃ¨re ligne)la description de ce que fait la fonction (deuxiÃ¨me paragraphe)la description de ce que fait la fonction (deuxiÃ¨me paragraphe)si vous renseignez un troisiÃ¨me paragraphe, cette partie ira dans la section â€œDetailsâ€ de la page dâ€™aidesi vous renseignez un troisiÃ¨me paragraphe, cette partie ira dans la section â€œDetailsâ€ de la page dâ€™aidela signification des paramÃ¨tresla signification des paramÃ¨tresla sortie, aprÃ¨s la balise @returnla sortie, aprÃ¨s la balise @returnGÃ©nÃ©rer la documentation Ã  lâ€™aide de â€œDocumentâ€ dans le menu â€œâ€ de lâ€™onglet â€œBuildâ€ (ou Ctrl+Shift+D ou devtools::document()). Lâ€™effet de cette commande est multiple :\nun dossier man Ã©tÃ© crÃ©Ã© et Ã  lâ€™intÃ©rieur, un fichier mvnpdf.Rd Ã©tÃ© crÃ©Ã© et contient les informations de lâ€™aide de la fonction\nle fichier NAMESPACE Ã©tÃ© modifiÃ©\nGÃ©nÃ©rer la documentation Ã  lâ€™aide de â€œDocumentâ€ dans le menu â€œâ€ de lâ€™onglet â€œBuildâ€ (ou Ctrl+Shift+D ou devtools::document()). Lâ€™effet de cette commande est multiple :un dossier man Ã©tÃ© crÃ©Ã© et Ã  lâ€™intÃ©rieur, un fichier mvnpdf.Rd Ã©tÃ© crÃ©Ã© et contient les informations de lâ€™aide de la fonctionun dossier man Ã©tÃ© crÃ©Ã© et Ã  lâ€™intÃ©rieur, un fichier mvnpdf.Rd Ã©tÃ© crÃ©Ã© et contient les informations de lâ€™aide de la fonctionle fichier NAMESPACE Ã©tÃ© modifiÃ©le fichier NAMESPACE Ã©tÃ© modifiÃ©En cas de bug ou par curiositÃ© ET une fois que vous avez terminÃ© vous pouvez consulter cette proposition.Pour plus de dÃ©tails sur la documentation de package et les balises\nroxygen2, voir la page\nObject documentation du site dâ€™Hadley.Finissons par Ã©voquer une fonction du package usethis qui initialise une\npage dâ€™aide pour le package dans son ensemble :La page dâ€™aide gÃ©nÃ©rÃ©e sera alors accessible, une fois le package installÃ©,\nvia :","code":"\nusethis::use_package_doc()\n?mypkgr"},{"path":"construire-un-package.html","id":"tester-le-package-de-maniÃ¨re-intÃ©ractive","chapter":"Chapitre 1 Construire un package ","heading":"1.4 Tester le package de maniÃ¨re intÃ©ractive","text":"Pour tester le package, vous devez le charger dans R Ã  lâ€™aide de :\ndans lâ€™onglet â€œBuildâ€, le menu â€œâ€ puis â€œLoad â€ (ou Ctrl+Shift+L ou\ndevtools::load_all()).Vous pouvez alors utiliser votre package directement dans R : consulter\nlâ€™aide de la fonction avec ?mvnpdf et par exemple exÃ©cuter les commandes renseignÃ©es dans la section exemple de cette page dâ€™aide.Ainsi, lors du dÃ©veloppement, vous pouvez :Ajouter/Modifier le code RAjouter/Modifier le code RRe-charger le package Ctrl+Shift+LRe-charger le package Ctrl+Shift+LEssayer dans la consoleEssayer dans la consoleEt ainsi de suiteâ€¦Et ainsi de suiteâ€¦","code":"\n?mvndpf"},{"path":"construire-un-package.html","id":"tester-le-package-de-maniÃ¨re-automatique","chapter":"Chapitre 1 Construire un package ","heading":"1.5 Tester le package de maniÃ¨re automatique","text":"Pour initialiser la fonctionnalitÃ© de tests automatiques dans le package,\nutiliser :Cette commande induit la crÃ©ation dâ€™un dossier tests qui comprend un fichier testthat.R - Ã  ne pas modifier - et un dossier testthat dans lequel va insÃ©rer nos tests. Cet outils sâ€™appuie sur la thÃ©orie des tests unitaires.Voici par exemple, le contenu dâ€™un fichier quâ€™appellera test-univariate.R Ã  mettre dans le dossier testthat :Et un deuxiÃ¨me, appelÃ© test-bivariate.R :Pour exÃ©cuter ces tests, peut utiliser dans lâ€™onglet â€œBuildâ€, le menu\nâ€œâ€, â€œTest packageâ€ (ou devtools::test() ou Ctrl+Shift+T).Lâ€™avantage de ces tests automatiques est quâ€™ils vont\nsâ€™exÃ©cuter Ã  chaque fois quâ€™effectuera un check du package.Une bonne pratique est dâ€™ajouter un test unitaire Ã  chaque fois quâ€™un bug est identifier et rÃ©solu,\nafin de pouvoir immÃ©diatement identifier et prÃ©venir quâ€™une erreur identique ne se reproduise dans\nle futur.","code":"\nusethis::use_testthat()\ntest_that(\"correct result for univariate gaussian\", {\n  expect_equal(mvnpdf(x=matrix(1.96), Log=FALSE)$y, dnorm(1.96))\n  expect_equal(mvnpdf(x=matrix(c(1.96, -0.5), ncol = 2), Log=FALSE)$y,\n               dnorm(c(1.96, -0.5)))\n})\ntest_that(\"correct results for bivariate gaussian\", {\n  expect_equal(mvnpdf(x=matrix(rep(1.96,2), nrow=2, ncol=1), Log=FALSE)$y,\n               mvtnorm::dmvnorm(rep(1.96, 2)))\n})"},{"path":"construire-un-package.html","id":"faire-un-check-du-package","chapter":"Chapitre 1 Construire un package ","heading":"1.6 Faire un check du package","text":"Faire un check signifie vÃ©rifier que tout est correct dans le package.\nIl est nÃ©cessaire de â€œpasserâ€ le check pour pouvoir dÃ©poser le package\nsur le CRAN.Pour exÃ©cuter celui-ci, utiliser â€œCheckâ€ dans lâ€™onglet â€œBuildâ€ (devtools::check() ou Ctrl+Shift+E).Lors du check, les tests que nous avons mis au point prÃ©cÃ©demment sont\nexÃ©cutÃ©es. Câ€™est justement lâ€™avantage dâ€™avoir fait ces tests, nous nâ€™avons\nplus besoin de sâ€™en prÃ©occuper, mais juste de rÃ©agir en cas dâ€™erreurs\nrenvoyÃ©es.","code":""},{"path":"construire-un-package.html","id":"installer-le-package","chapter":"Chapitre 1 Construire un package ","heading":"1.7 Installer le package","text":"Pour le moment, le package nâ€™existe que dans lâ€™environnement associÃ© au projet\nRstudio quâ€™crÃ©Ã©. Pour pouvoir lâ€™utiliser dans R de maniÃ¨re gÃ©nÃ©rale,\nil faut lâ€™installer (comme un package du CRAN par exemple).Pour faire Ã§a, utiliser â€œInstall Restartâ€ dans lâ€™onglet â€œBuildâ€ (devtools::install() ou Ctrl+Shift+B).Et enfin, vous pouvez configurer le comportement de Rstudio pour quâ€™au moment\nde lâ€™installation, il documente en mÃªme temps le package : aller dans\nlâ€™onglet â€œBuildâ€, le menu â€œâ€ puis â€œConfigure Build Toolsâ€. Cliquer ensuite\nsur â€œConfigureâ€ puis cocher la case en bas â€œInstall Restartâ€.","code":""},{"path":"construire-un-package.html","id":"annexe-1.1-ajouter-une-mÃ©thode-s3","chapter":"Chapitre 1 Construire un package ","heading":"1.8 Annexe 1.1 : ajouter une mÃ©thode S3","text":"Dans la plupart des packages est amenÃ©s Ã  implÃ©menter des mÃ©thodes S3,\ntrÃ¨s souvent pour quâ€™Ã  partir dâ€™un objet rÃ©sultat res, puisse exÃ©cuter\nprint(res), summary(res), plot(res)â€¦Voici un exemple de mÃ©thode plot() quâ€™peut ajouter dans notre package :Attention ! Pour que cette mÃ©thode fasse bien ce quâ€™veut quand \nlâ€™applique au rÃ©sultat de notre fonction mvnpdf(), il faut dÃ©clarer que\nce rÃ©sultat est de classe mvnpdf.Tester cette fonction, en exÃ©cutant lâ€™exemple.Nâ€™oubliez pas de rÃ©installer le package (â€œInstall Restartâ€ ou Ctrl+Shift+B).Consulter le contenu du dossier man et les modifications qui ont Ã©tÃ©\napportÃ©es au fichier NAMESPACE.Voici une proposition de solution : le\nfichier\ncontient le code complet\nde la fonction mvnpdf() et de la mÃ©thode plot() associÃ©e.","code":"\n#' Plot of the mvnpdf function\n#'\n#' @param x an object of class \\code{mvnpdf} resulting from a call of\n#' \\code{mnvpdf()} function.\n#' @param ... graphical parameters passed to \\code{plot()} function.\n#'\n#' @return Nothing is returned, only a plot is given.\n#' @export\n#'\n#' @examples\n#' pdfvalues <- mvnpdf(x=matrix(seq(-3, 3, by = 0.1), nrow = 1), Log=FALSE)\n#' plot(pdfvalues)\nplot.mvnpdf <- function(x, ...) {\n  plot(x$x, x$y, type = \"l\", ...)\n}"},{"path":"construire-un-package.html","id":"annexe-1.2-soumettre-son-package-au-cran","chapter":"Chapitre 1 Construire un package ","heading":"1.9 Annexe 1.2 : soumettre son package au CRAN","text":"devtools::check() puis devtools::submit_cran()","code":""},{"path":"construire-un-package.html","id":"annexe-1.3-construire-un-site-web-pour-accompagner-son-package","chapter":"Chapitre 1 Construire un package ","heading":"1.10 Annexe 1.3 : construire un site web pour accompagner son package","text":"usethis::use_pkgdown()","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","text":"Nous nous intÃ©ressons ici aux solutions proposÃ©es par RStudio et GitHub pour\nlâ€™hÃ©bergement et le contrÃ´le de version de projets.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"principe-du-contrÃ´le-de-version","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.1 Principe du contrÃ´le de version","text":"Le principe du contrÃ´le de version est dâ€™enregistrer les changements\nsuccessifs apportÃ©s Ã  des fichiers (notamment des fichiers R).RStudio propose 2 solutions intÃ©grÃ©es pour le contrÃ´le de version :gitgitsvnsvn","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"git","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.1.1 git","text":"git est un logiciel de contrÃ´le de version (câ€™est-Ã -dire un outils qui va\nenregistrer lâ€™histoire des changements successifs de votre code et permettre de\npartager ces changements avec dâ€™autres personnes). git est un logiciel en\nligne de commande, et sa prise en main nâ€™est pas nÃ©cessairement intuitive.git fonctionne de la faÃ§on suivante : sur un serveur dans le â€˜cloudâ€™,\nune version Ã  jour du code est disponible. Ã€ tout moment il est possible\ndâ€™accÃ©der Ã  cette version du code en ligne. Chaque contributeur peut tÃ©lÃ©charger\ncette derniÃ¨re version Ã  jour (dans une action que lâ€™dÃ©nomme pull),\navant de lâ€™Ã©diter localement. Une fois ses changements effectuÃ©s, le\ncontributeur peut alors mettre Ã  jour la version en ligne du code afin que ses\nchangements soient disponibles pour tout le monde (dans une action que lâ€™\ndÃ©nomme push)NB : git Ã©tÃ© pensÃ© pour des fichiers lÃ©gers (comme par exemple des\nfichiers texte) et est loin dâ€™Ãªtre optimisÃ© pour des fichiers trop lourds et/oÃ¹\ncompressÃ©s.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"subversion","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.1.2 subversion","text":"subversion est lâ€™autre solution disponible dans RStudio. Elle fonctionne de\nmaniÃ¨re similaire Ã  git, mais avec des fonctionnalitÃ©s un peu plus rÃ©duites\nque nous dÃ©taillons pas ici (la diffÃ©rence majeure est que tout les\ncontributeurs travaillent simultanÃ©ment sur la mÃªme version du code).","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"utiliser-git-localement-depuis-rstudio","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.2 Utiliser git localement depuis RStudio","text":"vous de jouer !Commencez par activer git depuis lâ€™onglet â€œGit/SVNâ€ de â€œProject Optionsâ€\nsituÃ© dans le menu â€œToolsâ€ et suivre les instructions. Vous pouvez aussi\nutilisÃ© usethis::use_git()Commencez par activer git depuis lâ€™onglet â€œGit/SVNâ€ de â€œProject Optionsâ€\nsituÃ© dans le menu â€œToolsâ€ et suivre les instructions. Vous pouvez aussi\nutilisÃ© usethis::use_git()Ã€ partir de lâ€™onglet â€œGitâ€ maintenant apparu Ã  cÃ´tÃ© de lâ€™onglet â€œBuildâ€,\nenregistrer lâ€™Ã©tat actuel de votre package en rÃ©alisant votre premier â€œcommitâ€ :Ã€ partir de lâ€™onglet â€œGitâ€ maintenant apparu Ã  cÃ´tÃ© de lâ€™onglet â€œBuildâ€,\nenregistrer lâ€™Ã©tat actuel de votre package en rÃ©alisant votre premier â€œcommitâ€ :2a. sÃ©lectionner les fichiers Ã  suivre (ne pas sÃ©lectionner le fichier .Rproj)2a. sÃ©lectionner les fichiers Ã  suivre (ne pas sÃ©lectionner le fichier .Rproj)2b. Ã©crire un message informatif (pour vos collaborateurs - ce qui inclut votre futur vous)2b. Ã©crire un message informatif (pour vos collaborateurs - ce qui inclut votre futur vous)2c. cliquer sur â€œCommitâ€2c. cliquer sur â€œCommitâ€Ajouter une ligne â€œ*.Rprojâ€ au fichier â€œ.gitignoreâ€ et effectuez un nouveau commitAjouter une ligne â€œ*.Rprojâ€ au fichier â€œ.gitignoreâ€ et effectuez un nouveau commitVisualiser les changements et leur historique Ã  lâ€™aide des outils de visualisation\nâ€œDiffâ€ et â€œHistoryâ€ accessible depuis lâ€™onglet â€œGitâ€Visualiser les changements et leur historique Ã  lâ€™aide des outils de visualisation\nâ€œDiffâ€ et â€œHistoryâ€ accessible depuis lâ€™onglet â€œGitâ€","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"bonnes-pratiques-du-commit","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.2.1 Bonnes pratiques du commit","text":"IdÃ©alement, chaque commit ne devrait rÃ©gler quâ€™un seul problÃ¨me. Il devrait le rÃ©gler dans\nson intÃ©gralitÃ© (Ãªtre complet) et ne contenir des changements relatifs quâ€™uniquement Ã \nce problÃ¨me (Ãªtre minimal). Il est alors important dâ€™Ã©crire des message de commit\ninformatifs (pensez Ã  vos collaborateur, qui incluent votre futur vous).\nIl faut Ã©galement Ãªtre concis, et dÃ©crire les raisons des changements plutÃ´t que\nles changements eux-mÃªmes (visibles dans le Diff). Il est parfois difficile de\nrespecter ces directives Ã  la lettre, et celles-ci ne sont quâ€™un guide et ne\ndoivent pas vous empÃªcher dâ€™effectuer des commits rÃ©guliers.Par ailleurs, la tentation dâ€™avoir un historique de changements â€œpropreâ€ et bien\nordonnÃ© est naturelle, mais se rÃ©vÃ¨le une source de problÃ¨mes inutiles. Elle\nentre en contradiction avec lâ€™objectif de traÃ§abilitÃ© du contrÃ´le de version.\nLe dÃ©veloppement de code Ã©tant gÃ©nÃ©ralement un processus intellectuel complexe\net non linÃ©aire, il est normal que lâ€™enregistrement des changements reflÃ¨te ce\ncheminement. En pratique, votre futur-vous sera le premier utilisateur de votre\nhistorique de changements et la prioritÃ© est donc de vous faciliter la tache\ndans le futur lors de la rÃ©solution de bug oÃ¹ lâ€™extension de fonctionnalitÃ©s.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"github","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.3 GitHub","text":"GitHub est un site internet proposant une solution\ndâ€™hÃ©bergement de code en ligne, et sâ€™appuyant sur git. Il existe de nombreux\nsites web et services (gitlab, bitbucket, â€¦) permettant dâ€™hÃ©berger du code et\nsâ€™appuyant sur git. GitHub est trÃ¨s populaire dans la communautÃ© des\ndÃ©veloppeurs R, et est relativement facile Ã  utiliser, mÃªme pour un\nutilisateur novice.Les avantages dâ€™utiliser GitHub :une interface graphique simple pour suivre lâ€™historique des changements de votre codeune interface graphique simple pour suivre lâ€™historique des changements de votre codela derniÃ¨re version de dÃ©veloppement de votre code est disponible en ligne et vous pouvez la\nrÃ©fÃ©rencer (peut mÃªme rÃ©fÃ©rencer un numÃ©ro de commit prÃ©cis pour geler une version spÃ©cifique\ndu code)la derniÃ¨re version de dÃ©veloppement de votre code est disponible en ligne et vous pouvez la\nrÃ©fÃ©rencer (peut mÃªme rÃ©fÃ©rencer un numÃ©ro de commit prÃ©cis pour geler une version spÃ©cifique\ndu code)les utilisateurs disposent dâ€™un canal clair et transparent pour signaler les bugs/difficultÃ©sles utilisateurs disposent dâ€™un canal clair et transparent pour signaler les bugs/difficultÃ©scela facilite grandement le dÃ©veloppement collaboratifcela facilite grandement le dÃ©veloppement collaboratif","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"mettre-son-package-r-sur-github","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.3.1 Mettre son package R sur GitHub","text":"vous de jouer !Rendez-vous sur le site https://github.com/ et crÃ©ez vous un compte\nGitHub (si vous hÃ©sitez, une convention courante est dâ€™utiliser prÃ©nomnom comme nom dâ€™utilisateur)Rendez-vous sur le site https://github.com/ et crÃ©ez vous un compte\nGitHub (si vous hÃ©sitez, une convention courante est dâ€™utiliser prÃ©nomnom comme nom dâ€™utilisateur)Vous pouvez ensuite soit utiliser le client â€œGitHub desktopâ€ installÃ© sur votre machine en vous connectant au compte GitHub et en suivant les instructions 3 et 4 suivantes, soit utiliser usethis::use_github() et vous laisser guider.Vous pouvez ensuite soit utiliser le client â€œGitHub desktopâ€ installÃ© sur votre machine en vous connectant au compte GitHub et en suivant les instructions 3 et 4 suivantes, soit utiliser usethis::use_github() et vous laisser guider.Ajouter un nouveau projet local en cliquant sur lâ€™icone â€œ+â€ en haut Ã  gauche de\nla fenÃªtre du client, puis en choississant â€œAddâ€ et en rentrant le chemin du dossier\noÃ¹ se trouve le code de votre package.Ajouter un nouveau projet local en cliquant sur lâ€™icone â€œ+â€ en haut Ã  gauche de\nla fenÃªtre du client, puis en choississant â€œAddâ€ et en rentrant le chemin du dossier\noÃ¹ se trouve le code de votre package.Une fois le repertoire crÃ©er en local, publiez le sur GitHub en cliquant sur â€œPublishâ€\nen haut Ã  droite de la fenÃªtre du client. VÃ©rifiez sur le site de GitHub que votre\ncode Ã  bien Ã©tÃ© uploadÃ© avec les 2 commits prÃ©cÃ©dents.Une fois le repertoire crÃ©er en local, publiez le sur GitHub en cliquant sur â€œPublishâ€\nen haut Ã  droite de la fenÃªtre du client. VÃ©rifiez sur le site de GitHub que votre\ncode Ã  bien Ã©tÃ© uploadÃ© avec les 2 commits prÃ©cÃ©dents.Ajouter un fichier â€œREADME.Rmdâ€ Ã  votre package afin de disposer dâ€™une belle page\ndâ€™accueil sur GitHub :Ajouter un fichier â€œREADME.Rmdâ€ Ã  votre package afin de disposer dâ€™une belle page\ndâ€™accueil sur GitHub :5a. dans RStudio, executez la commande usethis::use_readme_rmd()5a. dans RStudio, executez la commande usethis::use_readme_rmd()5b. Ã  lâ€™aide de lâ€™outilds â€œDiffâ€ de lâ€™onglet â€œGitâ€ de RStudio, Ã©tudier\nles changements opÃ©rer par la commande prÃ©cÃ©dente5b. Ã  lâ€™aide de lâ€™outilds â€œDiffâ€ de lâ€™onglet â€œGitâ€ de RStudio, Ã©tudier\nles changements opÃ©rer par la commande prÃ©cÃ©dente5c. Ã©ditez le fichier â€œREADME.Rmdâ€ crÃ©Ã©, puis crÃ©er le fichier README.md\ncorrespondant en executant knitr (cliquer su la pelotte de laine â€œKnitâ€\nen haut Ã  gauche dans Rstudio), avant dâ€™effectuer un 3e commit contenant ces\nchangements5c. Ã©ditez le fichier â€œREADME.Rmdâ€ crÃ©Ã©, puis crÃ©er le fichier README.md\ncorrespondant en executant knitr (cliquer su la pelotte de laine â€œKnitâ€\nen haut Ã  gauche dans Rstudio), avant dâ€™effectuer un 3e commit contenant ces\nchangements5d. Ã  ce stade, si vous visitez la page de votre rÃ©pertoire sur GitHub,\nvotre 3e commit nâ€™apparait pour lâ€™instant pas. Il faut synchroniser\nle rÃ©pertoire GitHub en ligne avec votre dossier local. Pour cela, vous\navez 2 solutions : soit utiliser le bouton â€œSyncâ€ en haut Ã  droit de la\nfenÃªtre du client GitHub desktop ; soit directement depuis RStudio en cliquant\nsur â€œPushâ€ depuis lâ€™onglet â€œGitâ€. Maintenant, les changements du 3e commit sont\nvisibles en ligne dur GitHub.5d. Ã  ce stade, si vous visitez la page de votre rÃ©pertoire sur GitHub,\nvotre 3e commit nâ€™apparait pour lâ€™instant pas. Il faut synchroniser\nle rÃ©pertoire GitHub en ligne avec votre dossier local. Pour cela, vous\navez 2 solutions : soit utiliser le bouton â€œSyncâ€ en haut Ã  droit de la\nfenÃªtre du client GitHub desktop ; soit directement depuis RStudio en cliquant\nsur â€œPushâ€ depuis lâ€™onglet â€œGitâ€. Maintenant, les changements du 3e commit sont\nvisibles en ligne dur GitHub.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"collaboration-pour-la-production-du-code","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4 Collaboration pour la production du code","text":"git et GitHub sont particuliÃ¨rement efficaces lorsque plusieurs personnes collaborent pour\ndÃ©velopper un code. En effet, chacun peut effectuer des pull et push successifs pour\napporter des changements au code, de maniÃ¨re simultanÃ©e et en Ã©tant sÃ»r de toujours travailler\nsur la derniÃ¨re version. Nous allons voir diffÃ©rents concepts utiles dans le cas dâ€™un tel travail\ncollaboratif.vous de jouer !En formant des groupes de 2, vous allez chacun ajouter votre binome comme â€œcollaboratorâ€\nÃ  votre repertoire GitHub Ã  partir de lâ€™onglet â€œSettingsâ€ (sur GitHub).En formant des groupes de 2, vous allez chacun ajouter votre binome comme â€œcollaboratorâ€\nÃ  votre repertoire GitHub Ã  partir de lâ€™onglet â€œSettingsâ€ (sur GitHub).Quelques instants plus tard le collaborateur ainsi ajoutÃ© reÃ§oit un email lâ€™invitant Ã \naccepter lâ€™ajout. Cliquer sur le lien et accepter.Quelques instants plus tard le collaborateur ainsi ajoutÃ© reÃ§oit un email lâ€™invitant Ã \naccepter lâ€™ajout. Cliquer sur le lien et accepter.Dans le client â€œGitHub desktopâ€, ajouter le rÃ©pertoire de votre binÃ´me en cliquant sur\nlâ€™icone â€œ+â€ en haut Ã  gauche et en selectionnant â€œCloneâ€, ce qui fait apparaitre la liste\ndes repertoires associÃ©s Ã  votre compte GitHub non liÃ©s Ã  un dossier local.\nSÃ©lectionner le projet de votre binome.Dans le client â€œGitHub desktopâ€, ajouter le rÃ©pertoire de votre binÃ´me en cliquant sur\nlâ€™icone â€œ+â€ en haut Ã  gauche et en selectionnant â€œCloneâ€, ce qui fait apparaitre la liste\ndes repertoires associÃ©s Ã  votre compte GitHub non liÃ©s Ã  un dossier local.\nSÃ©lectionner le projet de votre binome.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"branches","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.1 Branches","text":"Une des fonctionnalitÃ©s assez utile de git est les branches. Cela permet dâ€™opÃ©rer des changements\nimportants dans le code sans perturber le fonctionnement actuel. Câ€™est notamment utile pour explorer\nune piste de dÃ©veloppement dont ne sait pas si elle sera concluante au final.Dâ€™ailleurs, vous utilisez dÃ©jÃ  les branches depuis le depuis de cette partie. En effet, la branche\npar dÃ©faut est appelÃ© â€œmasterâ€.GrÃ¢ce Ã  ce systÃ¨me de branches, obtient un arbre des diffÃ©rents commits au cours du temps (oÃ¹\nles nÅ“uds correspondent Ã  la sÃ©parations des branches).","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"merge","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.2 Merge","text":"Un pull se dÃ©compose en 2 actions de la part de git :tout dâ€™abord un fetch, qui correspond au tÃ©lÃ©chargement du code en lignetout dâ€™abord un fetch, qui correspond au tÃ©lÃ©chargement du code en lignesuivi dâ€™un merge qui fusionne la version locale avec les changements.suivi dâ€™un merge qui fusionne la version locale avec les changements.AprÃ¨s avoir conduit un dÃ©veloppement expÃ©rimental dans une branche, peut vouloir merger ces\nchangements dans la branche â€œmasterâ€ par exemple, aprÃ¨s que lâ€™expÃ©rience se soit rÃ©vÃ©lÃ©e\nconcluante.Si un les changements concernent des parties distinctes du code, alors le merge peut\nsâ€™effectuer sans problÃ¨me. En revanche si les 2 versions Ã  merger comportent des changements\ndepuis leur dernier commit commun qui concerne les mÃªmes lignes de codes, alors va rencontrer\nun (ou des ) conflit(s), quâ€™il va falloir rÃ©soudre.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"les-conflits","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.3 Les conflits","text":"Prenons lâ€™exemple suivant : le dÃ©veloppeur \\(D_1\\) et le dÃ©veloppeur \\(D_2\\) tous les 2 pullÃ© la\nversion v0.1 du code Ã  lâ€™instant \\(t\\) sur leur machine respective. Ils travaillent chacun\nindÃ©pendamment pour apporter des changements au code. Au moment de pusher ses changements,\nle dÃ©veloppeur \\(D_2\\) reÃ§oit un message dâ€™erreur :â€œSync Error.\nPlease resolve conflicted files, commit, try syncing .â€Chaque fichier Ã©tant source de conflit alors Ã©tÃ© automatiquement Ã©ditÃ© comme suit :Pour rÃ©soudre le conflit, il faut alors Ã©diter chaque fichier un Ã  un en choisissant sâ€™il faut\nconserver la version locale ou bien celle en ligne, avant de pouvoir commiter Ã  nouveau et enfin\nde pusher vos changements avec succÃ¨s.vous de jouer !Modifiez le fichier README.Rmd de votre binome, puis commitez votre changement et pushez\nle.Modifiez le fichier README.Rmd de votre binome, puis commitez votre changement et pushez\nle.une fois que votre binÃ´me modifiÃ© votre README.Rmd, modifiez Ã  votre tour le fichier\nÃ  la mÃªme ligne, SANS puller les changements de votre binÃ´me au prÃ©alable ! Commitez et\nessayez de pusher ces changements.une fois que votre binÃ´me modifiÃ© votre README.Rmd, modifiez Ã  votre tour le fichier\nÃ  la mÃªme ligne, SANS puller les changements de votre binÃ´me au prÃ©alable ! Commitez et\nessayez de pusher ces changements.RÃ©solvez le conflit.RÃ©solvez le conflit.NB: Dans la vraie vie, cherche Ã  Ã©viter cette situation et donc va toujours puller avant de pusher. Ici, nous faisons volontairement le contraire pour donner un exemple et dÃ©mystifier les conflits.","code":"<<<<<<< HEAD\ncode dans votre version local\n=======\ncode en ligne\n>>>>>>> remote"},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"fork","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.4 Fork","text":"Lâ€™action fork permet de crÃ©er une copie qui vous appartient Ã  partir dâ€™un code disponible. Ainsi\nle code original ne sera pas impactÃ© par vos changements. Cela revient Ã  crÃ©er une branche, et la\nsÃ©parer de lâ€™arbre pour pouvoir en assumer la propriÃ©tÃ©. aurait aussi pu appeler cette action une â€œboutureâ€â€¦Cette action est principalement utile dans le cadre des pull requests.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"pull-request","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.5 Pull request","text":"Il sâ€™agit du moyen le plus facile de proposer des changements dans un code dont vous nâ€™Ãªtes pas\ncollaborateur. GitHub propose une interface graphique facilitant leur traitement.vous de jouer !Modifiez le README.Rmd de votre voisin qui nâ€™est pas votre binÃ´me aprÃ¨s avoir forkÃ© son\npackage.Modifiez le README.Rmd de votre voisin qui nâ€™est pas votre binÃ´me aprÃ¨s avoir forkÃ© son\npackage.Proposez votre changement sous la forme dâ€™une pull request depuis lâ€™onglet â€œPull requestsâ€ sur la page GitHub du rÃ©pertoire de votre voisin.Proposez votre changement sous la forme dâ€™une pull request depuis lâ€™onglet â€œPull requestsâ€ sur la page GitHub du rÃ©pertoire de votre voisin.Acceptez la pull request de votre voisin sur la page GitHub de votre rÃ©pertoire, puis faire le merge.Acceptez la pull request de votre voisin sur la page GitHub de votre rÃ©pertoire, puis faire le merge.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"issues","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.6 Issues","text":"Pour nâ€™importe quel rÃ©pertoire GitHub, vous pouvez poster un commentaire sous forme dâ€™issue\nafin dâ€™alerter les dÃ©veloppeurs sur un Ã©ventuel bug, ou une question sur lâ€™utilisation du package,\nou encore demander une fonctionnalitÃ© supplÃ©mentaireâ€¦Lâ€™idÃ©al est de proposer vous-mÃªme une pull request qui rÃ©sout votre issue lorsque vous\nle pouvez (.e.Â en avez les capacitÃ©s et le temps).vous de jouer !Utilisez usethis::use_github_links() afin dâ€™ajouter les 2 lignes suivantes au fichier DESCRIPTION de votre packageURL: http://github.com/*prenom.nom*/mypkgBugReports: http://github.com/*prenom.nom*/mypkg/issuesUtilisez usethis::use_github_links() afin dâ€™ajouter les 2 lignes suivantes au fichier DESCRIPTION de votre packageURL: http://github.com/*prenom.nom*/mypkgBugReports: http://github.com/*prenom.nom*/mypkg/issuesVisualisez les nouveau changements, puis commitez les.Visualisez les nouveau changements, puis commitez les.CrÃ©ez une issue sur le projet de votre binomeCrÃ©ez une issue sur le projet de votre binome","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"intÃ©gration-continue","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.5 IntÃ©gration continue","text":"Ã€ chaque changement, Ã  chaque commit donc, il y la possibilitÃ© dâ€™introduire 1 (ou plusieurs) bugs qui vont empÃªcher le package de passer le CRAN check. Si lâ€™accumule trop de ces bugs, au moment de soumettre la nouvelle version, il peut y avoir beaucoup de corrections Ã  apporter. Câ€™est dâ€™autant plus frustrant si le package passait le CRAN check auparavantâ€¦Les services dâ€™intÃ©gration continue permettent de checker votre package automatiquement aprÃ¨s chaque commit ! En cas dâ€™Ã©chec, vous recevez un mail qui vous en informe. Un certain nombre de ces services proposent une offre limitÃ©e gratuite pour les projets open-source.Une autre raison dâ€™utiliser lâ€™intÃ©gration continue est quâ€™elle permet de tester votre package sur des infrastructures diffÃ©rentes de la votre (e.g.Â Windows, Ubuntu, Mac OS) et pour diffÃ©rentes versions de  (current, develâ€¦)","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"github-actions","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.5.1 GitHub Actions","text":"Les Github actions permettent de lancer des actions automatiquement Ã  chaque fois que vous pushez sur GitHub La commande usethis::use_github_action_check_standard() permet dâ€™initialiser les Github Actions, et dâ€™ajouter lâ€™action R CMD CHECK du package.vous de jouer !Executez la commande usethis::use_github_action_check_standard() et commitez les changements et regardez ce quâ€™il se passe sur la page GitHubExecutez la commande usethis::use_github_action_check_standard() et commitez les changements et regardez ce quâ€™il se passe sur la page GitHubAjouter un badge Ã  votre README.md grÃ¢ce au code obtenu dans la console R et commitez ces changementsAjouter un badge Ã  votre README.md grÃ¢ce au code obtenu dans la console R et commitez ces changementsNâ€™hÃ©sitez pas Ã  consulter la page suivantes qui renseigne sur les diffÃ©rentes GitHub Actions disponibles pour les pacakges  : https://github.com/r-lib/actions/blob/v1/examples/README.md","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"r-hub","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.5.2 R-hub","text":"Le R consortium met Ã  disposition le R-hub builder,\n- et pour ambition de bientÃ´t proposer un service dâ€™intÃ©gration continue spÃ©cialement dÃ©diÃ© aux packages R.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"annexe-2.1-couverture-du-code","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub : historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.6 Annexe 2.1 : couverture du code","text":"Le package covr propose une solution pour mesurer la couverture des tests unitaires associÃ©s Ã  un\npackage. La couverture de test dÃ©termine la proportion du code source qui est effectivement utilisÃ©e\nlors de lâ€™exÃ©cution des tests unitaires. La mesure de la couverture du code renforce la fiabilitÃ©\ndâ€™un code et donne confiance Ã  ses utilisateurs potentiels.vous de jouer !Executez la commande usethis::use_coverage(), ajouter un joli badge Ã  votre README.md grÃ¢ce au code obtenu dans la console RCommitez ces changements.Pour plus dâ€™information nâ€™hÃ©sitez pas Ã  consulter la vignette de covr.","code":""},{"path":"mesurer-et-comparer-des-temps-dexÃ©cution.html","id":"mesurer-et-comparer-des-temps-dexÃ©cution","chapter":"Chapitre 3 Mesurer et comparer des temps dâ€™exÃ©cution","heading":"Chapitre 3 Mesurer et comparer des temps dâ€™exÃ©cution","text":"La premiÃ¨re Ã©tape avant dâ€™optimiser un code est de pouvoir mesurer son temps dâ€™exÃ©cution,\nafin de pouvoir comparer les temps dâ€™exÃ©cution entre diffÃ©rente implÃ©mentations.","code":""},{"path":"mesurer-et-comparer-des-temps-dexÃ©cution.html","id":"mesurer-des-temps-dexÃ©cution-avec-system.time","chapter":"Chapitre 3 Mesurer et comparer des temps dâ€™exÃ©cution","heading":"3.1 Mesurer des temps dâ€™exÃ©cution avec system.time()","text":"Pour mesure le temps dâ€™exÃ©cution dâ€™une commande R, peut utiliser la\nfonction system.time() comme ceci :Le problÃ¨me qui apparaÃ®t sur cet exemple est que lâ€™exÃ©cution est tellement\nrapide que system.time() affiche 0 (ou une valeur trÃ¨s proche).\nDe plus, voit quâ€™il y une certaine variabilitÃ© quand relance plusieurs\nfois la commande.Ainsi si souhaite comparer notre code avec la fonction mvtnorm::dmvnorm(),\nne peut pas utiliser system.time() :pourrait se dire quâ€™il faut augmenter la complexitÃ© de notre calcul, mais\nil y mieux : utiliser le package microbenchmark !","code":"\nsystem.time(mvnpdf(x=matrix(rep(1.96, 2), nrow=2, ncol=1), Log=FALSE))##    user  system elapsed \n##   0.001   0.001   0.002\nsystem.time(mvtnorm::dmvnorm(rep(1.96, 2)))##    user  system elapsed \n##   0.003   0.001   0.005"},{"path":"mesurer-et-comparer-des-temps-dexÃ©cution.html","id":"comparer-des-temps-dexÃ©cution-avec-microbenchmark","chapter":"Chapitre 3 Mesurer et comparer des temps dâ€™exÃ©cution","heading":"3.2 Comparer des temps dâ€™exÃ©cution avec microbenchmark()","text":"Comme son nom lâ€™indique, ce package permet justement de comparer des temps\ndâ€™exÃ©cution mÃªme quand ceux-ci sont trÃ¨s faibles. De plus, la fonction\nmicrobenchmark() va rÃ©pÃ©ter un certain nombre de fois lâ€™exÃ©cution des\ncommandes et donc va stabiliser le rÃ©sultat.Les deux fonctions mvnpdf() et dmnvorm() Ã©tant capables de prendre en\nentrÃ©e une matrice, peut Ã©galement comparer leurs comportements dans ce\ncas :Il sâ€™est passÃ© un quelque choseâ€¦ Et va diagnostiquer ce problÃ¨me dans la suite.","code":"\nlibrary(microbenchmark)\nmb <- microbenchmark(mvtnorm::dmvnorm(rep(1.96, 2)),\n                     mvnpdf(x=matrix(rep(1.96,2)), Log=FALSE),\n                     times=1000L)## Warning in microbenchmark(mvtnorm::dmvnorm(rep(1.96, 2)), mvnpdf(x =\n## matrix(rep(1.96, : less accurate nanosecond times to avoid potential integer\n## overflows\nmb## Unit: microseconds\n##                                           expr    min     lq     mean median\n##                 mvtnorm::dmvnorm(rep(1.96, 2)) 19.926 20.828 23.61055 21.361\n##  mvnpdf(x = matrix(rep(1.96, 2)), Log = FALSE) 18.327 19.270 20.28520 19.639\n##      uq      max neval cld\n##  22.181 1563.535  1000  a \n##  20.459   89.052  1000   b## Warning: The `guide` argument in `scale_*()` cannot be `FALSE`. This was deprecated in ggplot2 3.3.4.\n## â„¹ Please use \"none\" instead.\n## This warning is displayed once every 8 hours.\n## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\nn <- 100\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                       expr     min      lq\n##         mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))  23.411  24.477\n##  mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 268.468 271.707\n##       mean   median       uq     max neval cld\n##   28.21825  25.4200  26.8960  97.252   100  a \n##  281.37398 273.7365 282.1005 364.900   100   b"},{"path":"profiler-son-code.html","id":"profiler-son-code","chapter":"Chapitre 4 Profiler son code","heading":"Chapitre 4 Profiler son code","text":"parle de profiling en anglais. Il sâ€™agit de dÃ©terminer ce qui prend\ndu temps dans un code. Le Ã©tant une fois trouvÃ© le bloc de code qui prend\nle plus de temps dans lâ€™exÃ©cution dâ€™optimiser uniquement cette brique.Pour obtenir un profiling du code ci-dessous, sÃ©lectionner les lignes de code\ndâ€™intÃ©rÃªt et aller dans le menu â€œProfileâ€ puis â€œProfile Selected Linesâ€ (ou\nCtrl+Alt+Shift P).OK, get ! ConcatÃ©ner un vecteur au fur et Ã  mesure dans une boucle\nnâ€™est vraiment pas une bonne idÃ©e.","code":"\nn <- 10e4\npdfval <- mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)"},{"path":"profiler-son-code.html","id":"comparaison-avec-une-version-plus-habile-de-mnvpdf","chapter":"Chapitre 4 Profiler son code","heading":"4.1 Comparaison avec une version plus habile de mnvpdf()","text":"ConsidÃ©rons une nouvelle version de mvnpdf(), appelÃ©e mvnpdfsmart().\nTÃ©lÃ©charger le\nfichier puis\nlâ€™inclure dans le package.Profiler la commande suivante :effectivement rÃ©solu le problÃ¨me et apprend maintenant de maniÃ¨re plus\nfine ce qui prend du temps dans notre fonction.Pour confirmer que mvnpdfsmart() est effectivement bien plus rapide que\nmvnpdf() peut re-faire une comparaison avec microbenchmark() :Et peut Ã©galement voir si devient compÃ©titif avec dmvnorm() :Il y encore du travailâ€¦","code":"\nn <- 10e4\npdfval <- mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)\nn <- 1000\nmb <- microbenchmark(mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: milliseconds\n##                                                            expr      min\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3.083077\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2.310637\n##        lq     mean   median       uq      max neval cld\n##  3.224035 3.729692 3.355645 3.529587 8.155720   100  a \n##  2.338824 2.374991 2.357992 2.389172 2.578982   100   b\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   43.419\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3122.109\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2305.963\n##         lq       mean   median        uq      max neval cld\n##    49.7125   62.60003   58.671   71.6065   97.457   100 a  \n##  3342.6480 3739.18565 3415.854 3466.1605 7962.364   100  b \n##  2328.6360 2358.91573 2343.376 2368.6725 2492.185   100   c"},{"path":"profiler-son-code.html","id":"comparaison-avec-une-version-optimisÃ©e-dans-r","chapter":"Chapitre 4 Profiler son code","heading":"4.2 Comparaison avec une version optimisÃ©e dans R","text":"Boris est arrivÃ©e aprÃ¨s plusieurs recherches et tests Ã  une\nversion optimisÃ©e\navec les outils de R.Inclure la fonction mvnpdfoptim() dans le package, puis profiler cette\nfonction :Et un petit microbenchmark() :Pour finir peut profiler la fonction dmvnorm() :","code":"\nn <- 10e4\npdfval <- mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   43.419\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3099.723\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2304.159\n##  mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 1744.222\n##         lq       mean   median       uq       max neval  cld\n##    53.4845   64.94646   63.017   72.939   107.707   100 a   \n##  3274.5880 3689.51415 3387.379 3462.101 11497.589   100  b  \n##  2345.3230 2502.91593 2385.298 2418.672  6630.110   100   c \n##  1773.2090 1847.76545 1802.606 1849.387  4712.007   100    d\nn <- 10e5\npdfval <- mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))"},{"path":"rcpp-ou-comment-intÃ©grer-facilement-du-code-cdans-un-package-r.html","id":"rcpp-ou-comment-intÃ©grer-facilement-du-code-cdans-un-package-r","chapter":"Chapitre 5 Rcpp ou comment intÃ©grer facilement du code C++dans un package R","heading":"Chapitre 5 Rcpp ou comment intÃ©grer facilement du code C++dans un package R","text":"Rcpp (R-C-Plus-Plus) est un package qui facilite lâ€™interface entre C++ et R. R est un langage\ninterprÃ©tÃ©, ce qui facilite un certain nombre de choses (notamment nous donne accÃ¨s Ã  la console\ndans laquelle peut Ã©valuer du code Ã  la volÃ©e). NÃ©anmoins, cette facilitÃ© dâ€™utilisation se\ncompense entre autre par des temps de calcul supÃ©rieurs Ã  ceux de langages de plus bas niveau,\ntels que C, Fortran et C++ (mais qui nÃ©cessitent eux une compilation).dirigera le lecteur curieux vers le livre en ligne\nRcpp everyone de Masaki E. Tsuda, qui\nconstitue une ressource trÃ¨s complÃ¨te pour comprendre lâ€™utilisation de Rcpp en plus de\nlâ€™introduction que lâ€™peut trouver dans le livre Advanced R dâ€™Hadley\nWickham.","code":""},{"path":"rcpp-ou-comment-intÃ©grer-facilement-du-code-cdans-un-package-r.html","id":"premiÃ¨re-fonction-en-rcpp","chapter":"Chapitre 5 Rcpp ou comment intÃ©grer facilement du code C++dans un package R","heading":"5.1 PremiÃ¨re fonction en Rcpp","text":"vous de jouer !Afin de rendre votre package prÃªt pour lâ€™utilisation avec Rcpp, commencez par executer la commande\nsuivante :Constatez les changements apportÃ©sConstatez les changements apportÃ©sil faut Ã©galement ajouter les 2 commentaires roxygen suivants dans la page dâ€™aide du\npackage dans son ensemble :il faut Ã©galement ajouter les 2 commentaires roxygen suivants dans la page dâ€™aide du\npackage dans son ensemble :Nous allons maintenant crÃ©er une premiÃ¨re fonction en Rcpp permettant dâ€™inverser une matrice.\nPour cela, nous allons nous appuyer sur la library C++ Armadillo.\nIl sâ€™agit dâ€™une library dâ€™algÃ¨bre linÃ©aire moderne et simple, hautement optimisÃ©e, et interfacÃ©e\navec R via le package RcppArmadillo.C++ nâ€™est pas un langage trÃ¨s diffÃ©rent de R. Les principales diffÃ©rences qui nous concernent :C++est trÃ¨s efficaces pour le boucles (y compris les boucles emboÃ®tÃ©es). Attention :\nil y souvent un sens qui est plus rapide que lâ€™autre (ceci est dÃ» Ã  la maniÃ¨re dont C++ attribue\net parcours la mÃ©moire).C++est trÃ¨s efficaces pour le boucles (y compris les boucles emboÃ®tÃ©es). Attention :\nil y souvent un sens qui est plus rapide que lâ€™autre (ceci est dÃ» Ã  la maniÃ¨re dont C++ attribue\net parcours la mÃ©moire).Chaque commande doit se terminer par un point virgule â€˜;â€™Chaque commande doit se terminer par un point virgule â€˜;â€™C++est un langage typÃ© : il faut dÃ©clarer le type de chaque variable avant de pouvoir\nlâ€™utiliser.C++est un langage typÃ© : il faut dÃ©clarer le type de chaque variable avant de pouvoir\nlâ€™utiliser.vous de jouer !CrÃ©ez un nouveau fichier C++ depuis RStudio (via le menu File > New File > C++ File), et enregistrez le dans le dossier src. Prenez le temps de le lire et essayez de comprendre chaque ligne.CrÃ©ez un nouveau fichier C++ depuis RStudio (via le menu File > New File > C++ File), et enregistrez le dans le dossier src. Prenez le temps de le lire et essayez de comprendre chaque ligne.Compilez et chargez votre package (via le bouton â€œInstall Restartâ€) et essayez dâ€™utiliser la fonction timesTwo() depuis la console.Compilez et chargez votre package (via le bouton â€œInstall Restartâ€) et essayez dâ€™utiliser la fonction timesTwo() depuis la console.Installez le package RcppArmadillo, et nâ€™oubliez pas de faire les ajouts nÃ©cessaires dans DESCRIPTION (cf.Â usethis::use_rcpp_armadillo())Installez le package RcppArmadillo, et nâ€™oubliez pas de faire les ajouts nÃ©cessaires dans DESCRIPTION (cf.Â usethis::use_rcpp_armadillo())Ã€ lâ€™aide de lâ€™[introduction Ã  Rcpp]](http://adv-r..co.nz/Rcpp.html#rcpp-intro) de Hadley Wickham dans son livre Advanced R, ainsi que de la documentation du package RcppArmadillo de celle de la library C++ Armadillo, tentez dâ€™Ã©crire une courte fonction invC en C++ calculant lâ€™inverse dâ€™une matrice.Ã€ lâ€™aide de lâ€™[introduction Ã  Rcpp]](http://adv-r..co.nz/Rcpp.html#rcpp-intro) de Hadley Wickham dans son livre Advanced R, ainsi que de la documentation du package RcppArmadillo de celle de la library C++ Armadillo, tentez dâ€™Ã©crire une courte fonction invC en C++ calculant lâ€™inverse dâ€™une matrice.Lorsque vous avez rÃ©ussi Ã  compiler votre fonction invC et quâ€™elle est accessible depuis  crÃ©er une fonction mvnpdf_invC() Ã  partir de lâ€™implÃ©mentation de mvnpdfsmart en remplaÃ§ant uniquement les calculs dâ€™inverse matriciel par un appel Ã  invC.Lorsque vous avez rÃ©ussi Ã  compiler votre fonction invC et quâ€™elle est accessible depuis  crÃ©er une fonction mvnpdf_invC() Ã  partir de lâ€™implÃ©mentation de mvnpdfsmart en remplaÃ§ant uniquement les calculs dâ€™inverse matriciel par un appel Ã  invC.Evaluer le gain en performance de cette nouvelle implÃ©mentation mvnpdf_invC.Evaluer le gain en performance de cette nouvelle implÃ©mentation mvnpdf_invC.","code":"\ndevtools::use_rcpp()\n#' @useDynLib mypkgr\n#' @importFrom Rcpp sourceCpp, .registration = TRUE\nNULL\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdf_invC(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   44.362\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3128.013\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2319.083\n##  mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 1736.760\n##  mvnpdf_invC(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2308.915\n##         lq       mean    median        uq       max neval  cld\n##    57.0105   71.60773   71.7295   82.5945   121.729   100 a   \n##  3269.9960 3542.48897 3375.3250 3470.0145  7743.998   100  b  \n##  2356.2495 2509.33161 2379.7220 2423.2435 10112.486   100   c \n##  1789.4860 1931.05695 1825.0740 1853.6715  5658.410   100    d\n##  2351.1245 2517.90266 2375.3350 2410.1645  6439.214   100   c\nprofvis::profvis(mvnpdfoptim(x=matrix(1.96, \n    nrow = 2, ncol = 1000), Log=FALSE))\nprofvis::profvis(mvnpdfoptim(x=matrix(1.96, \n    nrow = 100, ncol = 1000), Log=FALSE))"},{"path":"rcpp-ou-comment-intÃ©grer-facilement-du-code-cdans-un-package-r.html","id":"optimisation-grÃ¢ce-Ã -c","chapter":"Chapitre 5 Rcpp ou comment intÃ©grer facilement du code C++dans un package R","heading":"5.2 Optimisation grÃ¢ce Ã  C++","text":"En rÃ¨gle gÃ©nÃ©rale, ne gagne pas beaucoup en temps de calcul en remplaÃ§ant une fonction R\noptimisÃ©e par une fonction en C++. En effet, la plupart des fonctions de base de R sâ€™appuie en\nrÃ©alitÃ© dÃ©jÃ  sur des routines C ou Fortran bien optimisÃ©e. Le gain se limite alors simplement\nÃ  la suppression des vÃ©rifications des arguments et de la gestion des diffÃ©rents types.vous de jouer !Ã€ partir de mvnpdfsmart, proposez une implÃ©mentation completement en C++ du calcul\nde densitÃ© de la loi Normale multivariÃ©e mvnpdfC().Ã€ partir de mvnpdfsmart, proposez une implÃ©mentation completement en C++ du calcul\nde densitÃ© de la loi Normale multivariÃ©e mvnpdfC().Evaluer le gain en performance de cette nouvelle implÃ©mentation mvnpdfCEvaluer le gain en performance de cette nouvelle implÃ©mentation mvnpdfCVous pouvez tÃ©lÃ©charger notre proposition de mvnpdfC.cpp ici.Ã€ noter que vous pouvez utiliser des fonctions Rcpp en dehors de lâ€™architecture\ndâ€™un package grÃ¢ce Ã  la fonction Rcpp::sourceCpp(). Mais comme nous avons\nquâ€™il est prÃ©fÃ©rable de gÃ©rer tous ces code sous la forme de package, il est\npeu probable que vous en ayez besoin !","code":"\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdf_invC(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfC(x=matrix(1.96, nrow = 2, ncol = n), mean = rep(0, 2), varcovM = diag(2), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                                                                  expr\n##                                                    mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))\n##                                             mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                        mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                        mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                        mvnpdf_invC(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##  mvnpdfC(x = matrix(1.96, nrow = 2, ncol = n), mean = rep(0, 2),      varcovM = diag(2), Log = FALSE)\n##       min        lq       mean    median        uq      max neval  cld\n##    43.829   53.4845   62.76772   60.9670   71.1555  100.901   100 a   \n##  3108.456 3257.2655 3560.86681 3430.4290 3485.0410 7903.242   100  b  \n##  2319.452 2349.0335 2414.52567 2369.4925 2393.5800 6000.391   100   c \n##  1736.924 1774.0700 1878.94841 1792.0485 1819.3135 5915.603   100    d\n##  2310.801 2338.6605 2541.02748 2354.9375 2383.0020 6964.465   100   c \n##    35.260   38.6835   48.45175   41.0205   43.4805  686.750   100 a"},{"path":"rcpp-ou-comment-intÃ©grer-facilement-du-code-cdans-un-package-r.html","id":"annexe-5.1-loptimisation-prÃ©maturÃ©e-nest-pas-une-bonne-idÃ©e","chapter":"Chapitre 5 Rcpp ou comment intÃ©grer facilement du code C++dans un package R","heading":"5.3 Annexe 5.1 : lâ€™optimisation prÃ©maturÃ©e nâ€™est pas une bonne idÃ©e","text":"Chambers, Software Data Analysis: Programming R, Springer, 2008 :Including additional C code serious step, added dangers\noften substantial amount programming debugging required.\ngood reason.","code":""},{"path":"parallÃ©lisation-du-code-r.html","id":"parallÃ©lisation-du-code-r","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"Chapitre 6 ParallÃ©lisation du code R","text":"","code":""},{"path":"parallÃ©lisation-du-code-r.html","id":"introduction-Ã -lexecution-parallÃ¨le-sous-r","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.1 Introduction Ã  lâ€™execution parallÃ¨le sous R","text":"En dehors de lâ€™optimisation du code et des algorithmes, une autre faÃ§on\ndâ€™obtenir un code performant est de tirer profit des architectures parallÃ¨les\ndes ordinateurs modernes. Il sâ€™agit alors de parallÃ©liser son code afin de\nfaire des opÃ©rations simultanÃ©es sur des parties distinctes dâ€™un mÃªme problÃ¨me,\nen utilisant diffÃ©rent cÅ“urs de calcul. ne rÃ©duit pas le temps de calcul\ntotal nÃ©cessaire, mais lâ€™ensemble des opÃ©rations sâ€™exÃ©cute plus rapidement.Il existe un nombre non nÃ©gligeable dâ€™algorithmes qui sont dâ€™un â€œparallÃ©lisme\nembarrassantâ€, câ€™est-Ã -dire dont les calculs peuvent se dÃ©composer en plusieurs\nsous-calculs indÃ©pendants. En statistique, il est ainsi souvent facile et direct\nde parallÃ©liser selon les diffÃ©rentes observations ou selon les diffÃ©rentes\ndimensions. Typiquement, il sâ€™agit dâ€™opÃ©rations que lâ€™peut Ã©crire sous la\nforme de boucle dont les opÃ©rations sont indÃ©pendantes dâ€™une itÃ©ration de la\nboucle Ã  lâ€™autre.Les opÃ©rations nÃ©cessaires pour lâ€™Ã©tablissement dâ€™un code parallÃ¨le sont les suivantes :DÃ©marrer \\(m\\) processus â€œtravailleursâ€ (.e.Â cÅ“urs de calcul) et les initialiserDÃ©marrer \\(m\\) processus â€œtravailleursâ€ (.e.Â cÅ“urs de calcul) et les initialiserEnvoyer les fonctions et donnÃ©es nÃ©cessaires pour chaque tache aux travailleursEnvoyer les fonctions et donnÃ©es nÃ©cessaires pour chaque tache aux travailleursSÃ©parer les taches en \\(m\\) opÃ©rations dâ€™envergure similaire et les envoyer aux travailleursSÃ©parer les taches en \\(m\\) opÃ©rations dâ€™envergure similaire et les envoyer aux travailleursAttendre que tous les travailleurs aient terminer leurs calculs et obtenir leurs rÃ©sultatsAttendre que tous les travailleurs aient terminer leurs calculs et obtenir leurs rÃ©sultatsRassembler les rÃ©sultats des diffÃ©rents travailleursRassembler les rÃ©sultats des diffÃ©rents travailleursArrÃªter les processus travailleursArrÃªter les processus travailleursSelon les plateformes, plusieurs protocoles de communications sont disponibles\nentre les cÅ“urs. Sous les systÃ¨mes UNIX, le protocole Fork est le plus\nutilisÃ©, mais il nâ€™est pas disponible sous Windows oÃ¹ utilise\nprÃ©fÃ©rentiellement le protocole PSOCK. Enfin, pour les architecture de calcul\ndistribuÃ©e oÃ¹ les cÅ“urs ne se trouvent pas nÃ©cessairement sur le mÃªme processeur\nphysique, utilise gÃ©nÃ©ralement le protocole MPI. Lâ€™avantage des packages\nfuture et future.apply est que le mÃªme code pourra Ãªtre exÃ©cutÃ© quelque soit\nla configuration matÃ©rielle.Il existe un nombre important de packages et dâ€™initiatives permettant de faire\ndu calcul en R. Depuis R 2.14.0, le package\nparallel\nest inclus directement dans R et permet de dÃ©marrer et dâ€™arrÃªter un â€œclusterâ€\nde plusieurs processus travailleur (Ã©tape 1 et 6). En plus du package\nparallel, va donc utiliser le package future qui permet de gÃ©rer les\nprocessus travailleurs et la communication et lâ€™articulation avec le package\nfuture.applyqui permet lui de gÃ©rer le dialogue avec les travailleurs (envois,\nrÃ©ception et rassemblement des rÃ©sultats - Ã©tapes 2, 3, 4 et 5).","code":""},{"path":"parallÃ©lisation-du-code-r.html","id":"premiÃ¨re-fonction-parallÃ¨le-en-r","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.2 PremiÃ¨re fonction parallÃ¨le en R","text":"Ã€ vous de jouer !Commencez par Ã©crire une fonction simple qui calcule le logarithme de \\(n\\)\nnombres:DÃ©terminez combien de coeurs sont disponibles sur votre marchine grÃ¢ce Ã \nla fonction future::availableCores().DÃ©terminez combien de coeurs sont disponibles sur votre marchine grÃ¢ce Ã \nla fonction future::availableCores().Ã€ lâ€™aide de la fonction future::plan(multisession(workers = XX)),\ndÃ©clarez un â€œplanâ€ de calculs parallÃ¨les sur votre ordinateur (en prenant garde\nÃ  laisser un coeur disponible pour traiter les autres processus).Ã€ lâ€™aide de la fonction future::plan(multisession(workers = XX)),\ndÃ©clarez un â€œplanâ€ de calculs parallÃ¨les sur votre ordinateur (en prenant garde\nÃ  laisser un coeur disponible pour traiter les autres processus).Ã€ lâ€™aide dâ€™une fonction de type apply future.apply::future_*apply(),\ncalculez le log des \\(n\\) nombres en parallÃ¨le et concatÃ©nez les rÃ©sultats dans un\nvecteur.Ã€ lâ€™aide dâ€™une fonction de type apply future.apply::future_*apply(),\ncalculez le log des \\(n\\) nombres en parallÃ¨le et concatÃ©nez les rÃ©sultats dans un\nvecteur.Comparez le temps dâ€™Ã©xecution avec celui dâ€™une fonction sÃ©quentielle\nsur les 100 premiers entiers, grÃ¢ce Ã  la commande :microbenchmark(log_par(1:100), log_seq(1:100), times=10)Comparez le temps dâ€™Ã©xecution avec celui dâ€™une fonction sÃ©quentielle\nsur les 100 premiers entiers, grÃ¢ce Ã  la commande :microbenchmark(log_par(1:100), log_seq(1:100), times=10)La version parallÃ¨le tourne beaucoup plus lentementâ€¦ Car en fait, si les\ntÃ¢ches individuelles sont trop rapides, R va passer plus de temps Ã \ncommuniquer avec les cÅ“urs, quâ€™Ã  faire les calculs effectifs.Il faut quâ€™une itÃ©ration de la boucle soit relativement longue pour que le\ncalcul parallÃ¨le apporte un gain en temps de calcul !En augmentant \\(n\\), observe une rÃ©duction de la diffÃ©rence entre les 2\nimplÃ©mentations (le temps de calcul en parallÃ¨le augmente trÃ¨s lentement comparÃ©\nÃ  lâ€™augmentation de celui de la fonction sÃ©quentielle).NB : les itÃ©rateurs dâ€™itertools sont trÃ¨s performants mais ne peuvent\nservir que lorsque le code Ã  lâ€™intÃ©rieur de future_*apply() est vectorisÃ© (il\nest toujours possible de vectoriser le code Ã  lâ€™intÃ©rieur, par exemple avec une\nfonction de type apply). Ils minimisent le nombre de communication entre les\ncoeurs.","code":"\nlibrary(microbenchmark)\nlibrary(future.apply)\n\nlog_seq <- function(x){\n  # try this yourself (spoiler alert: it is quite long...):\n  # res <- numeric(length(x))\n  # for(i in 1:length(x)){\n  #   res[i] <- log(x[i])\n  # }\n  # return(res)\n  return(log(x))\n}\n\nlog_par <- function(x){\n  res <- future_sapply(1:length(x), FUN = function(i) {\n    log(x[i])\n  })\n  return(res)\n}\n\nplan(multisession(workers = 3))\nmb <- microbenchmark(log_par(1:100), log_seq(1:100), times = 50)"},{"path":"parallÃ©lisation-du-code-r.html","id":"parallÃ©lisation-efficace","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.3 ParallÃ©lisation efficace","text":"va maintenant se pencher sur un autre cas dâ€™utilisation. Imaginons que lâ€™\nait un grand tableau de donnÃ©es de taille comportant 10 observations pour 100\n000 variables (e.g.Â des mesures de gÃ©nomique), et que lâ€™veuille calculer la\nmÃ©diane pour chacune de ces variables.Pour un utilisateur averti de R, une telle opÃ©ration se programme facilement\nÃ  lâ€™aide de la fonction apply :En rÃ©alitÃ©, une boucle nâ€™est pas plus lente Ã  condition dâ€™Ãªtre bien\nprogrammÃ©e :Ã€ vous de jouer !\nEssayez dâ€™amÃ©liorer encore ce temps de calcul en parallÃ©lisant :ParallÃ©lisez le calcul de la mÃ©diane de chacune des 100 000 variables.\nObserve-t-un gain en temps de calcul ?ParallÃ©lisez le calcul de la mÃ©diane de chacune des 100 000 variables.\nObserve-t-un gain en temps de calcul ?Proposez une implÃ©mentation alternative grÃ¢ce Ã  la fonction\nitertools::isplitIndices() qui permet de sÃ©parer vos donnÃ©es (les \\(n\\) nombres)\nen autant de groupes que vous avez de coeurs. Comparez Ã  nouveau les temps de\ncalcul.Proposez une implÃ©mentation alternative grÃ¢ce Ã  la fonction\nitertools::isplitIndices() qui permet de sÃ©parer vos donnÃ©es (les \\(n\\) nombres)\nen autant de groupes que vous avez de coeurs. Comparez Ã  nouveau les temps de\ncalcul.","code":"\nx <- matrix(rnorm(1e6), nrow = 10)\ndim(x)## [1]     10 100000\ncolmedian_apply <- function(x){\n  return(apply(x, 2, median))\n}\nsystem.time(colmedian_apply(x))##    user  system elapsed \n##   1.527   0.004   1.531\ncolmedian_for <- function(x){\n  ans <- rep(0, ncol(x)) \n  for (i in 1:ncol(x)) {\n    ans[i] <- median(x[, i]) \n  }\n  return(ans)\n}\nsystem.time(colmedian_for(x))##    user  system elapsed \n##   1.476   0.003   1.478\ncolmedian_par <- function(x){\n  res <- future_sapply(1:ncol(x), FUN = function(i) {\n          median(x[, i])\n    })\n  return(res)\n}\nplan(multisession(workers = 3))\nsystem.time(colmedian_par(x))##    user  system elapsed \n##   0.097   0.016   0.712\ncolmedian_parIter <- function(x, ncores = 1){\n  iter <- itertools::isplitIndices(n = ncol(x), chunks = ncores)\n  res <- future_sapply(iter, FUN = function(i) {\n          apply(x[, i], 2, median)\n    })\n  return(unlist(res))\n}\nsystem.time(colmedian_parIter(x, ncores = 3))##    user  system elapsed \n##   0.048   0.014   0.540\nmb <- microbenchmark(colmedian_apply(x), \n                     colmedian_for(x),\n                     colmedian_par(x),\n                     colmedian_parIter(x, ncores = 3), times = 10)\nmb## Unit: milliseconds\n##                              expr       min        lq      mean    median\n##                colmedian_apply(x) 1146.2693 1173.4495 1194.9441 1189.6657\n##                  colmedian_for(x) 1110.8893 1128.4085 1161.2218 1157.9027\n##                  colmedian_par(x)  552.1889  557.7954  565.7271  563.7149\n##  colmedian_parIter(x, ncores = 3)  492.4648  494.2154  501.4810  500.1446\n##         uq       max neval cld\n##  1207.9525 1263.9378    10 a  \n##  1189.2213 1239.7713    10 a  \n##   576.9173  578.1943    10  b \n##   502.7662  518.6836    10   c"},{"path":"parallÃ©lisation-du-code-r.html","id":"les-itÃ©rateurs","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.3.1 Les itÃ©rateurs","text":"Le package itertools permet de sÃ©parer facilement des donnÃ©es ou des\ntaches (Ã©tape 3) tout en minimisant les communications avec les diffÃ©rents\ntravailleurs. Il sâ€™appuie sur une implÃ©mentation des itÃ©rateurs en R.\nSon utilisation nÃ©cessite nÃ©anmoins de vectoriser le code Ã  lâ€™intÃ©rieur de\nfuture_*apply(). ExpÃ©rimentez avec le petit code ci-dessous :","code":"\nmyiter <- itertools::isplitIndices(n = 30, chunks = 3)\n\n# Une premiÃ¨re fois\niterators::nextElem(myiter)##  [1]  1  2  3  4  5  6  7  8  9 10\n# Une deuxiÃ¨me fois... Oh ?!\niterators::nextElem(myiter)##  [1] 11 12 13 14 15 16 17 18 19 20\n# Encore !\niterators::nextElem(myiter)##  [1] 21 22 23 24 25 26 27 28 29 30\n# Encore ?\niterators::nextElem(myiter)## Error: StopIteration"},{"path":"parallÃ©lisation-du-code-r.html","id":"les-autres-plans-de-calculs-parallÃ¨le","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.3.2 Les autres â€œplansâ€ de calculs parallÃ¨le","text":"Pour exÃ©cuter votre code (exactement le mÃªme code, câ€™est un des avantages\ndu packages de la famille future*), vous devez rÃ©gler un â€œplanâ€ de calculs :sur un ordinateur (ou un unique serveur de calcul) sous Unix (Linux, Mac OS),\nvous pouvez utiliser plan(multicore(workers = XX)) qui est souvent plus\nperformant. Le plan multisession fonctionne toujours.sur un ordinateur (ou un unique serveur de calcul) sous Unix (Linux, Mac OS),\nvous pouvez utiliser plan(multicore(workers = XX)) qui est souvent plus\nperformant. Le plan multisession fonctionne toujours.sur un cluster de calculs (type Avakas Ã  Bordeaux), nous renvoyons au package\nfuture.batchtoolssur un cluster de calculs (type Avakas Ã  Bordeaux), nous renvoyons au package\nfuture.batchtools","code":""},{"path":"parallÃ©lisation-du-code-r.html","id":"parallÃ©lisation-dans-notre-exemple-fil-rouge","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.4 ParallÃ©lisation dans notre exemple fil rouge","text":"Ã€ vous de jouer !Ã€ partir de la fonction mvnpdfoptim() et/ou mvnpdfsmart(), proposez\nune implÃ©mentation parallÃ©lisant les calculs sur les observations (colonnes de \\(x\\))Ã€ partir de la fonction mvnpdfoptim() et/ou mvnpdfsmart(), proposez\nune implÃ©mentation parallÃ©lisant les calculs sur les observations (colonnes de \\(x\\))Comparez les temps de calcul sur 10 000 observationsComparez les temps de calcul sur 10 000 observationsNotre proposition dâ€™implementation pour mvnpdfoptim_par est tÃ©lÃ©chargeable ici.","code":"\nplan(multisession(workers = 3))\nn <- 10000\nmb <- microbenchmark::microbenchmark(\n  mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n  mypkgr::mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n  mypkgr::mvnpdfoptim_par(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n  mypkgr::mvnpdfoptim_parIter(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE, ncores = 3),\n  times=20L)\nmb## Unit: microseconds\n##                                                                                             expr\n##                                               mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))\n##                           mypkgr::mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                  mypkgr::mvnpdfoptim_par(x = matrix(1.96, nrow = 2, ncol = n),      Log = FALSE)\n##  mypkgr::mvnpdfoptim_parIter(x = matrix(1.96, nrow = 2, ncol = n),      Log = FALSE, ncores = 3)\n##        min        lq       mean     median        uq        max neval cld\n##    175.562   215.578   225.8731   223.5525   233.618    280.071    20 a  \n##  13489.041 13781.801 14633.2772 14273.9655 14796.613  18171.692    20 ab \n##  32025.018 32836.592 33700.8233 33300.7740 34809.102  35935.680    20  bc\n##  31920.796 32473.722 45188.2894 33096.4300 34667.591 267307.413    20   c"},{"path":"parallÃ©lisation-du-code-r.html","id":"conclusion","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.5 Conclusion","text":"La parallÃ©lisation permet de gagner du temps, mais il faut dâ€™abord bien\noptimiser son code. Quand parallÃ©lise un code, le gain sur la durÃ©e\ndâ€™exÃ©cution dÃ©pend avant tout du ratio entre le temps de communication et le\ntemps de calcul effectif pour chaque tache.","code":""},{"path":"take-home-message.html","id":"take-home-message","chapter":"Chapitre 7 Take Home message","heading":"Chapitre 7 Take Home message","text":"FAITES DES PACKAGESFAITES DES PACKAGESutilisez git, au moins pour vous en localutilisez git, au moins pour vous en localsi besoin (.e.Â aprÃ¨s optimisation du code R lui mÃªme), nâ€™ayez pas peur de vous tourner vers Rcpp et/ou la\nparallÃ©lisation de votre codesi besoin (.e.Â aprÃ¨s optimisation du code R lui mÃªme), nâ€™ayez pas peur de vous tourner vers Rcpp et/ou la\nparallÃ©lisation de votre code","code":""},{"path":"rÃ©fÃ©rences.html","id":"rÃ©fÃ©rences","chapter":"RÃ©fÃ©rences","heading":"RÃ©fÃ©rences","text":"Les livres en ligne dâ€™Hadley Wickham sont vraiment excellents et contiennent\nbeaucoup de complÃ©ments par rapport Ã  tout ce que lâ€™traitÃ© dans cette\nformation :\nle site sur la construction de package R packages.\nle site Advanced R pour tout ce qui concerne\nlâ€™optimisation, Rcpp, ou encore le calcul parallÃ¨le.\nle site R Data Science est Ã©galement trÃ¨s\ncomplet et comprend des chapitres sur la gestion des structures de donnÃ©es\ndans R, mais aussi la modÃ©lisation ainsi que des Ã©lÃ©ments sur les graphiques et\nRmarkdown.\nLes livres en ligne dâ€™Hadley Wickham sont vraiment excellents et contiennent\nbeaucoup de complÃ©ments par rapport Ã  tout ce que lâ€™traitÃ© dans cette\nformation :le site sur la construction de package R packages.le site sur la construction de package R packages.le site Advanced R pour tout ce qui concerne\nlâ€™optimisation, Rcpp, ou encore le calcul parallÃ¨le.le site Advanced R pour tout ce qui concerne\nlâ€™optimisation, Rcpp, ou encore le calcul parallÃ¨le.le site R Data Science est Ã©galement trÃ¨s\ncomplet et comprend des chapitres sur la gestion des structures de donnÃ©es\ndans R, mais aussi la modÃ©lisation ainsi que des Ã©lÃ©ments sur les graphiques et\nRmarkdown.le site R Data Science est Ã©galement trÃ¨s\ncomplet et comprend des chapitres sur la gestion des structures de donnÃ©es\ndans R, mais aussi la modÃ©lisation ainsi que des Ã©lÃ©ments sur les graphiques et\nRmarkdown.le livre en ligne Rcpp everyone de\nMasaki E. Tsuda est Ã©galement trÃ¨s bien.le livre en ligne Rcpp everyone de\nMasaki E. Tsuda est Ã©galement trÃ¨s bien.","code":""}]
