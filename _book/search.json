[{"path":"index.html","id":"prÃ©sentation-de-la-formation","chapter":"PrÃ©sentation de la formation","heading":"PrÃ©sentation de la formation","text":"Le principal de cette formation est de vous donner des outils pour\nfaciliter le dÃ©veloppement de code (performant) avec . Lâ€™aspect â€œperformanceâ€\narrivera dans un deuxiÃ¨me temps, et les premiers outils prÃ©sentÃ©s sont\nÃ©galement trÃ¨s utiles dans des situations ne faisant pas intervenir de temps\nde calculs importants.Nous allons centrer la prÃ©sentation de ces outils de dÃ©veloppement autour\nde la notion de package. Vous connaissez dÃ©jÃ  cette notion, car vous avez\ndÃ©jÃ  installer des packages depuis le CRAN par exemple. Vous savez Ã©galement\nque câ€™est le moyen le plus standard dans  pour\npartager et mettre Ã  disposition du code.\nNous allons vous montrer que le package est Ã©galement un excellent outil pour\ndÃ©velopper le code.Nous allons adopter le plan suivant :Build R package useful tool code developmentLeverage git tracking changes, GitHub sharing code, collaborative development, automating tests package broadcast companion websiteLeverage git tracking changes, GitHub sharing code, collaborative development, automating tests package broadcast companion websiteConstruire un package  comme outils de dÃ©veloppement de codeConstruire un package  comme outils de dÃ©veloppement de codeUtiliser git pour tracer les changements, et GitHub pour partager son code, le dÃ©veloppement collaboratif, automatiser les tests dans un package et diffuser un site web dâ€™accompagnementUtiliser git pour tracer les changements, et GitHub pour partager son code, le dÃ©veloppement collaboratif, automatiser les tests dans un package et diffuser un site web dâ€™accompagnementMesurer le temps de calculMesurer le temps de calculProfiler le codeProfiler le codeUtiliser Rcpp pour optimiser ce qui doit lâ€™ÃªtreUtiliser Rcpp pour optimiser ce qui doit lâ€™ÃªtreParallÃ©liser facilement le codeParallÃ©liser facilement le code","code":""},{"path":"index.html","id":"logiciels-et-librairies-nÃ©cessaires-Ã -la-formation","chapter":"PrÃ©sentation de la formation","heading":"Logiciels et librairies nÃ©cessaires Ã  la formation","text":"Afin de suivre cette formation, il est nÃ©cessaire de disposer des logiciels suivants :la derniÃ¨re version de  (https://cloud.r-project.org/)la derniÃ¨re version de  (https://cloud.r-project.org/)la derniÃ¨re version de RStudio (https://posit.co/download/rstudio-desktop/#download)la derniÃ¨re version de RStudio (https://posit.co/download/rstudio-desktop/#download)un compilateur C++ (tel que gcc ou clang - natif sous les systÃ¨me UNIX,\npour les utilisateurs Windows nous recommandons lâ€™installation de\nRtools, pour les\nutilisateurs Mac il peut Ãªtre nÃ©cessaire dâ€™installer les outils de\ndÃ©veloppement Apple comme indiquÃ©\nici)un compilateur C++ (tel que gcc ou clang - natif sous les systÃ¨me UNIX,\npour les utilisateurs Windows nous recommandons lâ€™installation de\nRtools, pour les\nutilisateurs Mac il peut Ãªtre nÃ©cessaire dâ€™installer les outils de\ndÃ©veloppement Apple comme indiquÃ©\nici)les packages  suivants : devtools, future.apply, itertools, microbenchmark, mvtnorm, profvis, Rcpp, RcppArmadillo, roxygen2, testthat, usethisles packages  suivants : devtools, future.apply, itertools, microbenchmark, mvtnorm, profvis, Rcpp, RcppArmadillo, roxygen2, testthat, usethisle logiciel gitle logiciel gitle client GitHub Desktople client GitHub Desktop","code":""},{"path":"index.html","id":"prÃ©-requis","chapter":"PrÃ©sentation de la formation","heading":"PrÃ©-requis","text":"Afin de pouvoir suivre cette formation correctement vous devez Ãªtre Ã  lâ€™aise avec les aspects suivants :la programation avec  dans lâ€™environnement de dÃ©veloppement RStudioÃ©criture de fonctions en structure de contrÃ´le, en particulier les boucles forle calcul de la densitÃ© dâ€™une loi normale multivariÃ©e","code":""},{"path":"construire-un-package.html","id":"construire-un-package","chapter":"Chapitre 1 Construire un package ","heading":"Chapitre 1 Construire un package ","text":"Nous prÃ©sentons ici comment construire un package efficacement Ã  lâ€™aide dâ€™outils\ngraphiques prÃ©sents dans RStudio et du package devtools.Le support de rÃ©fÃ©rence sur ce sujet est le livre\nR packages1 dâ€™Hadley Wickham & Jennifer Bryan, disponible en ligne.","code":""},{"path":"construire-un-package.html","id":"initialiser-un-package","chapter":"Chapitre 1 Construire un package ","heading":"1.1 Initialiser un package","text":"Une maniÃ¨re simple, et intÃ©grÃ©e Ã  RStudio, pour initialiser un package est dâ€™executer les Ã©tapes suivantes :ğŸ‘‰ Ã€ vous de jouer (dÃ©jÃ )!crÃ©er un nouveau projet (menu dÃ©roulant en haut Ã  gauche dans RStudio)crÃ©er un nouveau projet (menu dÃ©roulant en haut Ã  gauche dans RStudio)choisir â€œNew Directoryâ€choisir â€œNew Directoryâ€choisir â€œR package using devtoolsâ€ (sâ€™il nâ€™est pas disponible câ€™est que le package devtools nâ€™est pas installer et dans ce cas peut alors choisir â€œR packageâ€ â€“ la diffÃ©rence Ã©tant quâ€™avec â€œR packageâ€, il faudra supprimer des fichiers crÃ©Ã©s automatiquement mais inutiles)choisir â€œR package using devtoolsâ€ (sâ€™il nâ€™est pas disponible câ€™est que le package devtools nâ€™est pas installer et dans ce cas peut alors choisir â€œR packageâ€ â€“ la diffÃ©rence Ã©tant quâ€™avec â€œR packageâ€, il faudra supprimer des fichiers crÃ©Ã©s automatiquement mais inutiles)donner un nom au package, par exemple mypkgr.donner un nom au package, par exemple mypkgr.rÃ©cupÃ¨re alors la structure minimale pour un package , Ã  savoir :un fichier DESCRIPTION dont les parties Title, Version, Authors@R et\nDescription sont Ã  Ã©diter (dâ€™autres parties pourront Ãªtre Ã©diter voire\nmÃªme ajouter de maniÃ¨re automatique, comme nous le verrons plus loin)un fichier DESCRIPTION dont les parties Title, Version, Authors@R et\nDescription sont Ã  Ã©diter (dâ€™autres parties pourront Ãªtre Ã©diter voire\nmÃªme ajouter de maniÃ¨re automatique, comme nous le verrons plus loin)un fichier NAMESPACE qui sera Ã©ditÃ© automatiquement ultÃ©rieurementun fichier NAMESPACE qui sera Ã©ditÃ© automatiquement ultÃ©rieurementun dossier R/ dans lequel va ajouter des fichiers de scripts .Run dossier R/ dans lequel va ajouter des fichiers de scripts .Rdevtools ajoute Ã©galement trois fichiers facultatifs :.gitignore, relatif Ã  git, outils de contrÃ´le de version que nous verrons en dÃ©tails dans la partie suivante sur git & GitHub.gitignore, relatif Ã  git, outils de contrÃ´le de version que nous verrons en dÃ©tails dans la partie suivante sur git & GitHubmypkgr.Rproj qui est un fichier spÃ©cifique de RStudio, et permet de dÃ©finirles caractÃ©ristiques et prÃ©fÃ©rences du projet que nous venons de crÃ©ermypkgr.Rproj qui est un fichier spÃ©cifique de RStudio, et permet de dÃ©finirles caractÃ©ristiques et prÃ©fÃ©rences du projet que nous venons de crÃ©er.Rbuildignore qui permet dâ€™ignorer certains fichiers au moment oÃ¹ construira le package un peu plus loin (par exemple, le fichier mypkgr.Rproj ne doit pas Ãªtre inclus dans le package).Rbuildignore qui permet dâ€™ignorer certains fichiers au moment oÃ¹ construira le package un peu plus loin (par exemple, le fichier mypkgr.Rproj ne doit pas Ãªtre inclus dans le package)","code":""},{"path":"construire-un-package.html","id":"ajouter-une-fonction-exemple-fil-rouge","chapter":"Chapitre 1 Construire un package ","heading":"1.2 Ajouter une fonction : exemple fil rouge","text":"Nous vous proposons de coder la fonction suivante, que nous reprendrons tout au\nlong de la formation :Nous souhaitons calculer la valeur de la densitÃ© dâ€™une loi normale multivariÃ©e\nsur \\(\\mathbb{R}^p\\) en \\(n\\) points. Notre fonction doit pouvoir sâ€™appliquer pour\nnâ€™importe quelle loi normale multivariÃ©e (vecteur de moyennes \\(\\boldsymbol \\mu\\) dans\n\\(\\mathbb{R}^p\\) et matrice de variance-covariance \\(\\boldsymbol\\Sigma\\) dâ€™ordre de \\(p\\) quelconques),\net souhaite pouvoir calculer toutes les valeurs de la densitÃ© Ã©valuÃ©es\nsur les \\(n\\) points \\(\\mathbf{x}\\) en un seul appel de la fonction.Pour rappel, la fonction de densitÃ© dâ€™une loi normale multivariÃ©e sâ€™Ã©crit :\n\\[\\displaystyle (2\\pi )^{-p/2}\\det({\\boldsymbol {\\Sigma }})^{-1/2}\\,\\exp \\left(-{\\frac {1}{2}}(\\mathbf {x} -{\\boldsymbol {\\mu }})^{\\mathsf {T}}{\\boldsymbol {\\Sigma }}^{-1}(\\mathbf {x} -{\\boldsymbol {\\mu }})\\right)\\]Vous devez donc crÃ©er une fonction mvnpdf() dans un fichier nommÃ© mvnpdf.R\ndans le dossier R/ du package, qui :prend en arguments :\nx une matrice, Ã  \\(n\\) colonnes (les observations) et \\(p\\) lignes\nmean un vecteur de moyennes\nvarcovM une matrice de variance-covariance\nLog un paramÃ¨tre logique valant TRUE par dÃ©faut\nprend en arguments :x une matrice, Ã  \\(n\\) colonnes (les observations) et \\(p\\) lignesx une matrice, Ã  \\(n\\) colonnes (les observations) et \\(p\\) lignesmean un vecteur de moyennesmean un vecteur de moyennesvarcovM une matrice de variance-covariancevarcovM une matrice de variance-covarianceLog un paramÃ¨tre logique valant TRUE par dÃ©fautLog un paramÃ¨tre logique valant TRUE par dÃ©fautrenvoie une liste contenant la matrice x ainsi quâ€™un vecteur des images\ndes points de x par la fonction de densitÃ© de la variable alÃ©atoire de loi\nnormale multivariÃ©e considÃ©rÃ©e.renvoie une liste contenant la matrice x ainsi quâ€™un vecteur des images\ndes points de x par la fonction de densitÃ© de la variable alÃ©atoire de loi\nnormale multivariÃ©e considÃ©rÃ©e.ğŸ‘‰ Ã€ vous de jouer !Voici une proposition de fonction que vous pouvez tÃ©lÃ©charger\nici. âš ï¸ ATTENTION ! Si vous cliquez trop vite sur le lien ci-dessous, cela invalidera votre participation Ã  la formation !Pour des conseils lors de la rÃ©daction de code, voir le chapitre\nR code dans R packages (2023) de Wickham & Bryan2.","code":""},{"path":"construire-un-package.html","id":"documenter-une-fonction","chapter":"Chapitre 1 Construire un package ","heading":"1.3 Documenter une fonction","text":"Il est important de bien documenter votre code. Tout projet au moins 2\ndÃ©veloppeurs :vousvousvous dans 6 moisvous dans 6 moisPar Ã©gard Ã  votre â€œfutur vousâ€, soyez sympas et prenez le temps de documenter\nvotre code ğŸ˜‰ !Nous vous conseillons vivement dâ€™utiliser le package roxygen2 pour documenter\nvos packages. Lâ€™avantage principal Ã©tant dâ€™avoir lâ€™aide dâ€™une fonction dans\nle mÃªme fichier que le code dÃ©finissant cette fonction.ğŸ‘‰ Ã€ vous de jouer !Commencer par insÃ©rer le squelette de lâ€™aide grÃ¢ce Ã  â€œInsert Roxygen\nSkeletonâ€ situÃ© dans le menu â€œCodeâ€ ou le sous-menu Baguette magique dans\nla fenÃªtre de script.Commencer par insÃ©rer le squelette de lâ€™aide grÃ¢ce Ã  â€œInsert Roxygen\nSkeletonâ€ situÃ© dans le menu â€œCodeâ€ ou le sous-menu Baguette magique dans\nla fenÃªtre de script.ComplÃ©ter la documentation en renseignant :\nle titre de la fonction (premiÃ¨re ligne)\nla description de ce que fait la fonction (deuxiÃ¨me paragraphe)\nsi vous renseignez un troisiÃ¨me paragraphe, cette partie ira dans la section â€œDetailsâ€ de la page dâ€™aide\nla signification des paramÃ¨tres\nla sortie, aprÃ¨s la balise @return\nComplÃ©ter la documentation en renseignant :le titre de la fonction (premiÃ¨re ligne)le titre de la fonction (premiÃ¨re ligne)la description de ce que fait la fonction (deuxiÃ¨me paragraphe)la description de ce que fait la fonction (deuxiÃ¨me paragraphe)si vous renseignez un troisiÃ¨me paragraphe, cette partie ira dans la section â€œDetailsâ€ de la page dâ€™aidesi vous renseignez un troisiÃ¨me paragraphe, cette partie ira dans la section â€œDetailsâ€ de la page dâ€™aidela signification des paramÃ¨tresla signification des paramÃ¨tresla sortie, aprÃ¨s la balise @returnla sortie, aprÃ¨s la balise @returnGÃ©nÃ©rer la documentation Ã  lâ€™aide de â€œDocumentâ€ dans le menu â€œâ€ de lâ€™onglet â€œBuildâ€ (ou Ctrl+Shift+D ou devtools::document()). Lâ€™effet de cette commande est multiple :\nun dossier man Ã©tÃ© crÃ©Ã© et Ã  lâ€™intÃ©rieur, un fichier mvnpdf.Rd Ã©tÃ© crÃ©Ã© et contient les informations de lâ€™aide de la fonction\nle fichier NAMESPACE Ã©tÃ© modifiÃ©\nGÃ©nÃ©rer la documentation Ã  lâ€™aide de â€œDocumentâ€ dans le menu â€œâ€ de lâ€™onglet â€œBuildâ€ (ou Ctrl+Shift+D ou devtools::document()). Lâ€™effet de cette commande est multiple :un dossier man Ã©tÃ© crÃ©Ã© et Ã  lâ€™intÃ©rieur, un fichier mvnpdf.Rd Ã©tÃ© crÃ©Ã© et contient les informations de lâ€™aide de la fonctionun dossier man Ã©tÃ© crÃ©Ã© et Ã  lâ€™intÃ©rieur, un fichier mvnpdf.Rd Ã©tÃ© crÃ©Ã© et contient les informations de lâ€™aide de la fonctionle fichier NAMESPACE Ã©tÃ© modifiÃ©le fichier NAMESPACE Ã©tÃ© modifiÃ©En cas de bug ou par curiositÃ© ET une fois que vous avez terminÃ© vous pouvez consulter cette proposition.Pour plus de dÃ©tails sur la documentation de package et les balises\nroxygen2, voir la page\nObject documentation du site dâ€™Hadley.Finissons par Ã©voquer une fonction du package usethis qui initialise une\npage dâ€™aide pour le package dans son ensemble :La page dâ€™aide gÃ©nÃ©rÃ©e sera alors accessible, une fois le package installÃ©,\nvia :","code":"\nusethis::use_package_doc()\n?mypkgr"},{"path":"construire-un-package.html","id":"tester-le-package-de-maniÃ¨re-intÃ©ractive","chapter":"Chapitre 1 Construire un package ","heading":"1.4 Tester le package de maniÃ¨re intÃ©ractive","text":"Pour tester le package, vous devez le charger dans R Ã  lâ€™aide de :\ndans lâ€™onglet â€œBuildâ€, le menu â€œâ€ puis â€œLoad â€ (ou Ctrl+Shift+L ou\ndevtools::load_all()).Vous pouvez alors utiliser votre package directement dans R : consulter\nlâ€™aide de la fonction avec ?mvnpdf et par exemple exÃ©cuter les commandes renseignÃ©es dans la section exemple de cette page dâ€™aide.Ainsi, lors du dÃ©veloppement, vous pouvez :Ajouter/Modifier le code Ajouter/Modifier le code Re-charger le package Ctrl+Shift+LRe-charger le package Ctrl+Shift+LLâ€™essayer dans la consoleLâ€™essayer dans la consoleEt ainsi de suiteâ€¦Et ainsi de suiteâ€¦","code":"\n?mvndpf"},{"path":"construire-un-package.html","id":"tester-le-package-de-maniÃ¨re-automatique","chapter":"Chapitre 1 Construire un package ","heading":"1.5 Tester le package de maniÃ¨re automatique","text":"Pour initialiser la fonctionnalitÃ© de tests automatiques dans le package, executer la commande suivante :Cette commande induit la crÃ©ation dâ€™un dossier tests qui comprend un fichier testthat.R â€“ Ã  ne pas modifier â€“ et un dossier testthat/ dans lequel va insÃ©rer nos tests. Cet outils sâ€™appuie sur la thÃ©orie des tests unitaires.Voici par exemple le contenu dâ€™un fichier contenant 2 tests qui devrait sâ€™appeller test-mvnpdf.R Ã  mettre dans le dossier testthat/ (plutÃ´t que de le crÃ©er vous-mÃªme, vous pouvez simplement utiliser la fonction usethis::use_test() qui crÃ©era le fichier pour vous en le plaÃ§ant directement au bon endroit) :Pour exÃ©cuter ces tests, peut utiliser â€œTest packageâ€ (Ctrl+Shift+T) du menu â€œâ€ dans lâ€™onglet â€œBuildâ€, ou alors executer devtools::test() dans la console.Lâ€™avantage de ces tests automatiques est quâ€™ils vont\nsâ€™exÃ©cuter Ã  chaque fois quâ€™effectuera un check du package.Une bonne pratique est dâ€™ajouter un test unitaire Ã  chaque fois quâ€™un bug est identifiÃ© et rÃ©solu,\nafin de pouvoir immÃ©diatement identifier et prÃ©venir quâ€™une erreur identique ne se reproduise dans\nle futur.","code":"\nusethis::use_testthat()\ntest_that(\"correct result for univariate gaussian\", {\n  expect_equal(mvnpdf(x=matrix(1.96), Log=FALSE)$y, dnorm(1.96))\n  expect_equal(mvnpdf(x=matrix(c(1.96, -0.5), ncol = 2), Log=FALSE)$y,\n               dnorm(c(1.96, -0.5)))\n})\n\ntest_that(\"correct results for bivariate gaussian\", {\n  expect_equal(mvnpdf(x=matrix(rep(1.96,2), nrow=2, ncol=1), Log=FALSE)$y,\n               mvtnorm::dmvnorm(rep(1.96, 2)))\n})"},{"path":"construire-un-package.html","id":"faire-un-check-du-package","chapter":"Chapitre 1 Construire un package ","heading":"1.6 Faire un check du package","text":"Faire un check signifie vÃ©rifier que tout est correct dans le package et fonctionne comme attendu, afin que l package puisse sâ€™installer sans problÃ¨me sur diffÃ©rents systÃ¨mes dâ€™exploitation. Il est impÃ©ratif de â€œpasserâ€ le R CMD CHECK pour pouvoir dÃ©poser un package sur le CRAN.Pour exÃ©cuter celui-ci, utiliser â€œCheckâ€ (Ctrl+Shift+E) dans lâ€™onglet â€œBuildâ€, ou alors executez devtools::check() dans la console.Lors du R CMD CHECK, les tests que nous avons mis au point prÃ©cÃ©demment sont exÃ©cutÃ©es. Câ€™est justement lâ€™avantage dâ€™avoir fait ces tests, nous nâ€™avons plus besoin de sâ€™en prÃ©occuper, mais juste de rÃ©agir en cas dâ€™erreurs renvoyÃ©es.","code":""},{"path":"construire-un-package.html","id":"installer-le-package","chapter":"Chapitre 1 Construire un package ","heading":"1.7 Installer le package","text":"Pour le moment, le package nâ€™existe que dans lâ€™environnement associÃ© au projet Rstudio quâ€™crÃ©Ã©. Pour pouvoir lâ€™utiliser dans R de maniÃ¨re gÃ©nÃ©rale, il faut lâ€™installer (comme un package du CRAN par exemple).Pour faire Ã§a, utiliser â€œInstall Restartâ€ Ctrl+Shift+B dans lâ€™onglet â€œBuildâ€ (devtools::install() ou ).Et enfin, vous pouvez configurer le comportement de RStudio pour quâ€™au moment de lâ€™installation, il documente en mÃªme temps le package : aller dans lâ€™onglet â€œBuildâ€, le menu â€œâ€ puis â€œConfigure Build Toolsâ€¦â€. Cliquer ensuite sur â€œConfigureâ€ juste Ã  cÃ´tÃ© de â€œGenerate documentation Roxygenâ€ puis cocher la case â€œInstall Restartâ€.","code":""},{"path":"construire-un-package.html","id":"annexe-1.1-ajouter-une-mÃ©thode-s3","chapter":"Chapitre 1 Construire un package ","heading":"Annexe 1.1 : ajouter une mÃ©thode S3","text":"Dans la plupart des packages est amenÃ©s Ã  implÃ©menter des mÃ©thodes S3,\ntrÃ¨s souvent pour quâ€™Ã  partir dâ€™un objet rÃ©sultat res, puisse exÃ©cuter\nprint(res), summary(res), plot(res)â€¦Voici un exemple de mÃ©thode plot() quâ€™peut ajouter dans notre package :âš ï¸ ATTENTION ! Pour que cette mÃ©thode fasse bien ce quâ€™veut quand \nlâ€™applique au rÃ©sultat de notre fonction mvnpdf(), il faut dÃ©clarer que\nce rÃ©sultat est de classe mvnpdf.Tester cette fonction, en exÃ©cutant lâ€™exemple.Nâ€™oubliez pas de rÃ©installer le package (â€œInstall Restartâ€ ou Ctrl+Shift+B).Consulter le contenu du dossier man et les modifications qui ont Ã©tÃ©\napportÃ©es au fichier NAMESPACE.Voici une proposition de solution : le\nfichier\ncontient le code complet\nde la fonction mvnpdf() et de la mÃ©thode plot() associÃ©e.","code":"\n#' Plot of the mvnpdf function\n#'\n#' @param x an object of class \\code{mvnpdf} resulting from a call of\n#' \\code{mnvpdf()} function.\n#' @param ... graphical parameters passed to \\code{plot()} function.\n#'\n#' @return Nothing is returned, only a plot is given.\n#' @export\n#'\n#' @examples\n#' pdfvalues <- mvnpdf(x=matrix(seq(-3, 3, by = 0.1), nrow = 1), Log=FALSE)\n#' plot(pdfvalues)\nplot.mvnpdf <- function(x, ...) {\n  plot(x$x, x$y, type = \"l\", ...)\n}"},{"path":"construire-un-package.html","id":"annexe-1.2-soumettre-son-package-au-cran","chapter":"Chapitre 1 Construire un package ","heading":"Annexe 1.2 : soumettre son package au CRAN","text":"Executer les 2 commandes suivantes : devtools::check() puis devtools::submit_cran().Pour plus de dÃ©tails, voir la procÃ©dure recommandÃ©e dans Wickham & Bryan (2023)3","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","text":"Nous nous intÃ©ressons ici aux solutions proposÃ©es par RStudio et GitHub pour le contrÃ´le de version de projets, lâ€™hÃ©bergement de vos projets et lâ€™automatisation dâ€™un certain nombre de vÃ©rifications garantissant un partage facile de votre code.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"principe-du-contrÃ´le-de-version","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.1 Principe du contrÃ´le de version","text":"Le principe du contrÃ´le de version est dâ€™enregistrer les changements successifs apportÃ©s Ã  des fichiers (notamment des fichiers .R).RStudio propose 2 solutions intÃ©grÃ©es pour le contrÃ´le de version :gitgitsvn (â€œsubversionâ€)svn (â€œsubversionâ€)","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"git","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.1.1 git","text":"git est un logiciel de contrÃ´le de version (câ€™est-Ã -dire un outils qui va\nenregistrer lâ€™histoire des changements successifs de votre code et permettre de\npartager ces changements avec dâ€™autres personnes). git est un logiciel en\nligne de commande, et sa prise en main nâ€™est pas nÃ©cessairement intuitive.git fonctionne de la faÃ§on suivante : sur un serveur distant (par exemple dans le cloud), une version Ã  jour du code est disponible. Ã€ tout moment il est possible dâ€™accÃ©der Ã  cette version du code en ligne. Chaque contributeur peut tÃ©lÃ©charger cette derniÃ¨re version Ã  jour (dans une action que lâ€™dÃ©nomme pull), avant de lâ€™Ã©diter localement. Une fois ses changements effectuÃ©s, le contributeur peut alors mettre Ã  jour la version en ligne du code afin que ses changements soient disponibles pour tout le monde (dans une action que lâ€™dÃ©nomme push)NB : git Ã©tÃ© pensÃ© pour des fichiers lÃ©gers (comme par exemple des\nfichiers texte) et est loin dâ€™Ãªtre optimisÃ© pour des fichiers trop lourds et/oÃ¹ compressÃ©s.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"subversion","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.1.2 subversion","text":"subversion est lâ€™autre solution disponible dans RStudio. Elle fonctionne de maniÃ¨re similaire Ã  git, mais avec des fonctionnalitÃ©s un peu plus rÃ©duites\nque nous dÃ©taillons pas ici (la diffÃ©rence majeure est que tout les contributeurs travaillent simultanÃ©ment sur la mÃªme version du code).","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"utiliser-git-localement-depuis-rstudio","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.2 Utiliser git localement depuis RStudio","text":"ğŸ‘‰ Ã€ vous de jouer !Commencer par activer git depuis lâ€™onglet â€œGit/SVNâ€ de â€œProject Optionsâ€\nsituÃ© dans le menu â€œToolsâ€ et suivre les instructions. Vous pouvez aussiplutÃ´t utiliser usethis::use_git()Commencer par activer git depuis lâ€™onglet â€œGit/SVNâ€ de â€œProject Optionsâ€\nsituÃ© dans le menu â€œToolsâ€ et suivre les instructions. Vous pouvez aussiplutÃ´t utiliser usethis::use_git()Ã€ partir de lâ€™onglet â€œGitâ€ maintenant apparu Ã  cÃ´tÃ© de lâ€™onglet â€œBuildâ€,\nenregistrer lâ€™Ã©tat actuel de votre package en rÃ©alisant votre premier â€œcommitâ€ :Ã€ partir de lâ€™onglet â€œGitâ€ maintenant apparu Ã  cÃ´tÃ© de lâ€™onglet â€œBuildâ€,\nenregistrer lâ€™Ã©tat actuel de votre package en rÃ©alisant votre premier â€œcommitâ€ :2a. sÃ©lectionner les fichiers Ã  suivre (ne pas sÃ©lectionner le fichier .Rproj)2a. sÃ©lectionner les fichiers Ã  suivre (ne pas sÃ©lectionner le fichier .Rproj)2b. Ã©crire un message informatif (pour vos collaborateurs - ce qui inclut votre futur vous)2b. Ã©crire un message informatif (pour vos collaborateurs - ce qui inclut votre futur vous)2c. cliquer sur â€œCommitâ€2c. cliquer sur â€œCommitâ€Ajouter une ligne â€œ*.Rprojâ€ au fichier â€œ.gitignoreâ€ et effectuez un nouveau commitAjouter une ligne â€œ*.Rprojâ€ au fichier â€œ.gitignoreâ€ et effectuez un nouveau commitVisualiser les changements et leur historique Ã  lâ€™aide des outils de visualisation\nâ€œDiffâ€ et â€œHistoryâ€ accessible depuis lâ€™onglet â€œGitâ€Visualiser les changements et leur historique Ã  lâ€™aide des outils de visualisation\nâ€œDiffâ€ et â€œHistoryâ€ accessible depuis lâ€™onglet â€œGitâ€","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"bonnes-pratiques-du-commit","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.2.1 Bonnes pratiques du commit","text":"IdÃ©alement, chaque commit ne devrait rÃ©gler quâ€™un seul problÃ¨me. Il devrait le rÃ©gler dans son intÃ©gralitÃ© (Ãªtre complet) et ne contenir des changements relatifs quâ€™uniquement Ã  ce problÃ¨me (Ãªtre minimal). Il est alors important dâ€™Ã©crire des messages de commit informatifs (pensez Ã  vos collaborateur, qui incluent votre futur vous). Il faut Ã©galement Ãªtre concis, et dÃ©crire les raisons des changements plutÃ´t que\nles changements eux-mÃªmes (visibles dans le Diff).NB : Il est parfois difficile de respecter ces directives Ã  la lettre, et celles-ci ne sont quâ€™un guide et ne doivent pas vous empÃªcher dâ€™effectuer des commits rÃ©guliers.Par ailleurs, la tentation dâ€™avoir un historique de changements â€œpropreâ€ et bien ordonnÃ© est naturelle, mais se rÃ©vÃ¨le une source de problÃ¨mes inutiles. Elle entre en contradiction avec lâ€™objectif de traÃ§abilitÃ© du contrÃ´le de version. Le dÃ©veloppement de code Ã©tant gÃ©nÃ©ralement un processus intellectuel complexe et non linÃ©aire, il est normal que lâ€™enregistrement des changements reflÃ¨te ce cheminement. En pratique, votre futur-vous sera le premier utilisateur de votre historique de changements et la prioritÃ© est donc de vous faciliter la tache dans le futur lors de la rÃ©solution de bug oÃ¹ lâ€™extension de fonctionnalitÃ©s.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"github","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.3 GitHub","text":"GitHub est un site internet proposant une solution\ndâ€™hÃ©bergement de code en ligne, et sâ€™appuyant sur git. Il existe de nombreux\nsites web et services (GitLab, Bitbucket, â€¦) permettant dâ€™hÃ©berger du code et\nsâ€™appuyant sur git. GitHub est trÃ¨s populaire dans la communautÃ© des\ndÃ©veloppeurs , et est relativement facile Ã  utiliser, mÃªme pour un\nutilisateur novice.Les avantages dâ€™utiliser GitHub sont :une interface graphique simple pour suivre lâ€™historique des changements de votre codeune interface graphique simple pour suivre lâ€™historique des changements de votre codela derniÃ¨re version de dÃ©veloppement de votre code est disponible en ligne et vous pouvez la\nrÃ©fÃ©rencer (peut mÃªme rÃ©fÃ©rencer un numÃ©ro de commit prÃ©cis pour geler une version spÃ©cifique\ndu code)la derniÃ¨re version de dÃ©veloppement de votre code est disponible en ligne et vous pouvez la\nrÃ©fÃ©rencer (peut mÃªme rÃ©fÃ©rencer un numÃ©ro de commit prÃ©cis pour geler une version spÃ©cifique\ndu code)les utilisateurs disposent dâ€™un canal clair et transparent pour signaler les bugs/difficultÃ©sles utilisateurs disposent dâ€™un canal clair et transparent pour signaler les bugs/difficultÃ©scela facilite grandement le dÃ©veloppement collaboratifcela facilite grandement le dÃ©veloppement collaboratif","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"mettre-son-package-sur-github","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.3.1 Mettre son package  sur GitHub","text":"ğŸ‘‰ Ã€ vous de jouer !Sur le site https://github.com/, se crÃ©er un compte GitHub (si vous hÃ©sitez, une convention courante est dâ€™utiliser prÃ©nomnom comme nom dâ€™utilisateur)Vous pouvez ensuite executer usethis::use_github() dans la console  et vous laisser guider.Ajouter un fichier â€œREADME.Rmdâ€ Ã  votre package afin de disposer dâ€™une belle page\ndâ€™accueil sur GitHub :\n3a. dans , executez la commande usethis::use_readme_rmd()\n3b. Ã  lâ€™aide de lâ€™outils â€œDiffâ€ de lâ€™onglet â€œGitâ€ de RStudio, Ã©tudier les changements opÃ©rÃ©s par la commande prÃ©cÃ©dente\n3c. Ã©ditez le fichier â€œREADME.Rmdâ€ crÃ©Ã©, puis crÃ©er le fichier README.md correspondant en executant knitr (cliquer su la pelotte de laine â€œKnitâ€ en haut Ã  gauche dans Rstudio), avant dâ€™effectuer un 3e commit contenant ces changements\n3d. Ã  ce stade, si vous visitez la page de votre rÃ©pertoire sur GitHub,\nvotre 3e commit nâ€™apparait pour lâ€™instant pas. Il faut synchroniser\nle rÃ©pertoire GitHub en ligne avec votre dossier local. Pour cela, directement depuis RStudio, cliquer sur â€œPushâ€ depuis lâ€™onglet â€œGitâ€. Maintenant, les changements du 3e commit sont visibles en ligne sur GitHub.\n3a. dans , executez la commande usethis::use_readme_rmd()3b. Ã  lâ€™aide de lâ€™outils â€œDiffâ€ de lâ€™onglet â€œGitâ€ de RStudio, Ã©tudier les changements opÃ©rÃ©s par la commande prÃ©cÃ©dente3c. Ã©ditez le fichier â€œREADME.Rmdâ€ crÃ©Ã©, puis crÃ©er le fichier README.md correspondant en executant knitr (cliquer su la pelotte de laine â€œKnitâ€ en haut Ã  gauche dans Rstudio), avant dâ€™effectuer un 3e commit contenant ces changements3d. Ã  ce stade, si vous visitez la page de votre rÃ©pertoire sur GitHub,\nvotre 3e commit nâ€™apparait pour lâ€™instant pas. Il faut synchroniser\nle rÃ©pertoire GitHub en ligne avec votre dossier local. Pour cela, directement depuis RStudio, cliquer sur â€œPushâ€ depuis lâ€™onglet â€œGitâ€. Maintenant, les changements du 3e commit sont visibles en ligne sur GitHub.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"collaboration-pour-la-production-du-code","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4 Collaboration pour la production du code","text":"git et GitHub sont particuliÃ¨rement efficaces lorsque plusieurs personnes collaborent pour dÃ©velopper un code. En effet, chacun peut effectuer des pull et push successifs pour apporter des changements au code, de maniÃ¨re simultanÃ©e et en Ã©tant sÃ»r de toujours travailler sur la derniÃ¨re version. Nous allons voir diffÃ©rents concepts utiles dans le cas dâ€™un tel travail\ncollaboratif.ğŸ‘‰ Ã€ vous de jouer !En formant des groupes de 2, vous allez chacun ajouter votre binome comme â€œcollaboratorâ€ Ã  votre repertoire GitHub Ã  partir de lâ€™onglet â€œSettingsâ€ (sur GitHub).En formant des groupes de 2, vous allez chacun ajouter votre binome comme â€œcollaboratorâ€ Ã  votre repertoire GitHub Ã  partir de lâ€™onglet â€œSettingsâ€ (sur GitHub).Quelques instants plus tard le collaborateur ainsi ajoutÃ© reÃ§oit un email lâ€™invitant Ã  accepter lâ€™ajout. Cliquer sur le lien et accepter.Quelques instants plus tard le collaborateur ainsi ajoutÃ© reÃ§oit un email lâ€™invitant Ã  accepter lâ€™ajout. Cliquer sur le lien et accepter.Dans RStudio, crÃ©er un nouveau projet â€œVersion controlâ€ Ã  partir de lâ€™url https du rÃ©pertoire de votre binÃ´me sur GitHub.Dans RStudio, crÃ©er un nouveau projet â€œVersion controlâ€ Ã  partir de lâ€™url https du rÃ©pertoire de votre binÃ´me sur GitHub.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"branches","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.1 Branches","text":"Une des fonctionnalitÃ©s assez utile de git est les branches. Cela permet dâ€™opÃ©rer des changements importants dans le code sans perturber le fonctionnement actuel. Câ€™est notamment utile pour explorer une piste de dÃ©veloppement dont ne sait pas si elle sera concluante au final.Dâ€™ailleurs, vous utilisez dÃ©jÃ  les branches depuis le depuis de cette partie. En effet, la branche par dÃ©faut est appelÃ© â€œmainâ€ (ou parfois â€œmasterâ€).GrÃ¢ce Ã  ce systÃ¨me de branches, obtient un arbre des diffÃ©rents commits au cours du temps (oÃ¹ les nÅ“uds correspondent Ã  la sÃ©parations des branches).","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"merge","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.2 Merge","text":"Un pull se dÃ©compose en 2 actions de la part de git :tout dâ€™abord un fetch, qui correspond au tÃ©lÃ©chargement du code en lignetout dâ€™abord un fetch, qui correspond au tÃ©lÃ©chargement du code en lignesuivi dâ€™un merge qui fusionne la version locale avec les changements.suivi dâ€™un merge qui fusionne la version locale avec les changements.AprÃ¨s avoir conduit un dÃ©veloppement expÃ©rimental dans une branche, peut vouloir merger ces\nchangements dans la branche â€œmasterâ€ par exemple, aprÃ¨s que lâ€™expÃ©rience se soit rÃ©vÃ©lÃ©e\nconcluante.Si un les changements concernent des parties distinctes du code, alors le merge peut\nsâ€™effectuer sans problÃ¨me. En revanche si les 2 versions Ã  merger comportent des changements\ndepuis leur dernier commit commun qui concerne les mÃªmes lignes de codes, alors va rencontrer\nun (ou des ) conflit(s), quâ€™il va falloir rÃ©soudre.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"les-conflits","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.3 Les conflits","text":"Prenons lâ€™exemple suivant : le dÃ©veloppeur \\(D_1\\) et le dÃ©veloppeur \\(D_2\\) tous les 2 pullÃ© la version v0.1 du code Ã  lâ€™instant \\(t\\) sur leur machine respective. Ils travaillent chacun indÃ©pendamment pour apporter des changements au code. Au moment de pusher ses changements, le dÃ©veloppeur \\(D_2\\) reÃ§oit un message dâ€™erreur :Chaque fichier Ã  la source source dâ€™un conflit alors Ã©tÃ© automatiquement Ã©ditÃ© comme suit :Pour rÃ©soudre le conflit, il faut alors Ã©diter chaque fichier un Ã  un en choisissant sâ€™il faut conserver la version locale ou bien celle en ligne, avant de pouvoir commiter Ã  nouveau et enfin de pusher vos changements avec succÃ¨s.ğŸ‘‰ Ã€ vous de jouer !Modifiez le fichier README.Rmd de votre binome, puis commitez votre changement et pushez le.une fois que votre binÃ´me modifiÃ© votre README.Rmd, modifiez Ã  votre tour le fichier Ã  la mÃªme ligne, SANS puller les changements de votre binÃ´me au prÃ©alable ! Commitez et essayez de pusher ces changements.RÃ©solvez le conflit.NB: Dans la vraie vie, cherche Ã  Ã©viter cette situation et donc va toujours puller avant de pusher. Ici, nous faisons volontairement le contraire pour donner un exemple et dÃ©mystifier les conflits.","code":"\"Sync Error.  \nPlease resolve all conflicted files, commit, then try syncing again.\"<<<<<<< HEAD\ncode dans votre version local\n=======\ncode en ligne\n>>>>>>> remote"},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"fork","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.4 Fork","text":"Lâ€™action fork permet de crÃ©er une copie qui vous appartient Ã  partir dâ€™un code disponible. Ainsi\nle code original ne sera pas impactÃ© par vos changements. Cela revient Ã  crÃ©er une branche, et la\nsÃ©parer de lâ€™arbre pour pouvoir en assumer la propriÃ©tÃ©. aurait aussi pu appeler cette action une â€œboutureâ€â€¦Cette action est principalement utile dans le cadre des pull requests.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"pull-request","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.5 Pull request","text":"Il sâ€™agit du moyen le plus facile de proposer des changements dans un code dont vous nâ€™Ãªtes pas\ncollaborateur. GitHub propose une interface graphique facilitant leur traitement.ğŸ‘‰ Ã€ vous de jouer !Modifiez le README.Rmd de votre voisin qui nâ€™est pas votre binÃ´me aprÃ¨s avoir forkÃ© son\npackage.Modifiez le README.Rmd de votre voisin qui nâ€™est pas votre binÃ´me aprÃ¨s avoir forkÃ© son\npackage.Proposez votre changement sous la forme dâ€™une pull request depuis lâ€™onglet â€œPull requestsâ€ sur la page GitHub du rÃ©pertoire de votre voisin.Proposez votre changement sous la forme dâ€™une pull request depuis lâ€™onglet â€œPull requestsâ€ sur la page GitHub du rÃ©pertoire de votre voisin.Acceptez la pull request de votre voisin sur la page GitHub de votre rÃ©pertoire, puis faire le merge.Acceptez la pull request de votre voisin sur la page GitHub de votre rÃ©pertoire, puis faire le merge.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"issues","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.4.6 Issues","text":"Pour nâ€™importe quel rÃ©pertoire GitHub, vous pouvez poster un commentaire sous forme dâ€™issue\nafin dâ€™alerter les dÃ©veloppeurs sur un Ã©ventuel bug, ou une question sur lâ€™utilisation du package,\nou encore demander une fonctionnalitÃ© supplÃ©mentaireâ€¦Lâ€™idÃ©al est de proposer vous-mÃªme une pull request qui rÃ©sout votre issue lorsque vous\nle pouvez (.e.Â en avez les capacitÃ©s et le temps).ğŸ‘‰ Ã€ vous de jouer !Utilisez usethis::use_github_links() afin dâ€™ajouter les 2 lignes suivantes au fichier DESCRIPTION de votre packageURL: http://github.com/*prenom.nom*/mypkgBugReports: http://github.com/*prenom.nom*/mypkg/issuesUtilisez usethis::use_github_links() afin dâ€™ajouter les 2 lignes suivantes au fichier DESCRIPTION de votre packageURL: http://github.com/*prenom.nom*/mypkgBugReports: http://github.com/*prenom.nom*/mypkg/issuesVisualisez les nouveau changements, puis commitez les.Visualisez les nouveau changements, puis commitez les.CrÃ©ez une issue sur le projet de votre binomeCrÃ©ez une issue sur le projet de votre binome","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"intÃ©gration-continue","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.5 IntÃ©gration continue","text":"Ã€ chaque changement, Ã  chaque commit donc, il y la possibilitÃ© dâ€™introduire 1 (ou plusieurs) bugs qui vont empÃªcher le package de passer le CRAN check. Si lâ€™accumule trop de ces bugs, au moment de soumettre la nouvelle version, il peut y avoir beaucoup de corrections Ã  apporter. Câ€™est dâ€™autant plus frustrant si le package passait le CRAN check auparavantâ€¦Les services dâ€™intÃ©gration continue permettent de checker votre package automatiquement aprÃ¨s chaque commit ! En cas dâ€™Ã©chec, vous recevez un mail qui vous en informe. Un certain nombre de ces services proposent une offre limitÃ©e gratuite pour les projets open-source.Une autre raison dâ€™utiliser lâ€™intÃ©gration continue est quâ€™elle permet de tester votre package sur des infrastructures diffÃ©rentes de la votre (e.g.Â Windows, Ubuntu, Mac OS) et pour diffÃ©rentes versions de  (current, develâ€¦)","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"github-actions","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.5.1 GitHub Actions","text":"Les GitHub Actions permettent de lancer des actions automatiquement Ã  chaque fois que vous pushez sur GitHub La commande usethis::use_github_action(\"check-standard\") permet dâ€™initialiser les Github Actions, et dâ€™ajouter lâ€™action R CMD CHECK du package.ğŸ‘‰ Ã€ vous de jouer !Executer la commande usethis::use_github_action(\"check-standard\") et commiter les changements et regardez ce quâ€™il se passe sur la page GitHubExecuter la commande usethis::use_github_action(\"check-standard\") et commiter les changements et regardez ce quâ€™il se passe sur la page GitHubAjouter un badge Ã  votre README.md grÃ¢ce au code obtenu dans la console  et commiter ces changementsAjouter un badge Ã  votre README.md grÃ¢ce au code obtenu dans la console  et commiter ces changementsNâ€™hÃ©sitez pas Ã  consulter la page suivantes qui renseigne sur les diffÃ©rentes GitHub Actions disponibles pour les pacakges  : https://github.com/r-lib/actions/blob/v2-branch/examples/README.md","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"construire-et-dÃ©ployer-simplement-un-site-web-pour-accompagner-son-package","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.6 Construire et dÃ©ployer simplement un site web pour accompagner son package","text":"Le package pkgdown permet de gÃ©nÃ©rer automatiquement un site web attrayant rassemblant la documentation de votre package (y compris les Vignettes).ğŸ‘‰ Ã€ vous de jouer !Executer la commande usethis::use_pkgdown() dans la console .Executer la commande usethis::use_pkgdown() dans la console .Commiter et pusher les changements. Rendez-vous sur lâ€™onglet Actions de votre rÃ©pertoire sur GitHub et constater les nouveautÃ©s.Commiter et pusher les changements. Rendez-vous sur lâ€™onglet Actions de votre rÃ©pertoire sur GitHub et constater les nouveautÃ©s.ğŸ‘‰ Ã€ vous de jouer !Examiner les changement du fichier DESCRIPTION suite Ã  lâ€™execution des diffÃ©rentes commandes usethis::use_... prÃ©cedemment.Modifier le champ URL du fichier DESCRIPTION.","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"rÃ©fÃ©rences-additionnelles","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"2.7 RÃ©fÃ©rences additionnelles","text":"Happy Git R Jenny Bryan.Happy Git R Jenny Bryan.Jennifer Bryan (2018). Excuse , Moment Talk Version Control? American Statistician 72 (1):20â€“27.DOI: 10.1080/00031305.2017.1399928Jennifer Bryan (2018). Excuse , Moment Talk Version Control? American Statistician 72 (1):20â€“27.DOI: 10.1080/00031305.2017.1399928","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"annexe-2.1-r-hub","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"Annexe 2.1 : R-hub","text":"Le R consortium met Ã  disposition le R-hub builder, â€“ et pour ambition de pouvoir un jour proposer un service dâ€™intÃ©gration continue spÃ©cialement dÃ©diÃ© aux packages .R-hub builder utilise exactement la mÃªme infrasrtructure que les serveurs du CRAN, ce qui lâ€™avantage de pouvoir reproduire exactement le R CMD CHECK tel quâ€™effectuÃ© par le CRAN. Il est possible de lâ€™utiliser grÃ¢ce Ã  la fonction devtools::check_rhub().","code":""},{"path":"contrÃ´le-de-version-avec-git-et-github-historique-de-changement-dÃ©veloppement-collaboratif-et-intÃ©gration-continue.html","id":"annexe-2.2-couverture-du-code","chapter":"Chapitre 2 ContrÃ´le de version avec git et GitHub: historique de changement, dÃ©veloppement collaboratif et intÃ©gration continue","heading":"Annexe 2.2 : couverture du code","text":"Le package covr propose une solution pour mesurer la couverture des tests unitaires associÃ©s Ã  un package. La couverture de test dÃ©termine la proportion du code source qui est effectivement utilisÃ©e lors de lâ€™exÃ©cution des tests unitaires. La mesure de la couverture du code renforce la fiabilitÃ© dâ€™un code et donne confiance Ã  ses utilisateurs potentiels.ğŸ‘‰ Ã€ vous de jouer !Executer la commande usethis::use_coverage(), ajouter un joli badge Ã  votre README.md grÃ¢ce au code obtenu dans la console .Commiter ces changements.Pour plus dâ€™information nâ€™hÃ©sitez pas Ã  consulter la vignette de covr.","code":""},{"path":"mesurer-et-comparer-des-temps-dexÃ©cution.html","id":"mesurer-et-comparer-des-temps-dexÃ©cution","chapter":"Chapitre 3 Mesurer et comparer des temps dâ€™exÃ©cution","heading":"Chapitre 3 Mesurer et comparer des temps dâ€™exÃ©cution","text":"La premiÃ¨re Ã©tape avant dâ€™optimiser un code est de pouvoir mesurer son temps dâ€™exÃ©cution, afin de pouvoir comparer les temps dâ€™exÃ©cution entre diffÃ©rente implÃ©mentations.Pour plus de dÃ©tails Ã  propos du contenu de ce chapitre ainsi que du suivant, nous renvoyons au livre dâ€™Hadley Wickham Advanced R 4, librement accessible en ligne.","code":""},{"path":"mesurer-et-comparer-des-temps-dexÃ©cution.html","id":"mesurer-des-temps-dexÃ©cution-avec-system.time","chapter":"Chapitre 3 Mesurer et comparer des temps dâ€™exÃ©cution","heading":"3.1 Mesurer des temps dâ€™exÃ©cution avec system.time()","text":"Pour mesurer le temps dâ€™exÃ©cution dâ€™une commande , peut utiliser la fonction system.time() comme ceci :Le problÃ¨me qui apparaÃ®t sur cet exemple est que lâ€™exÃ©cution est tellement\nrapide que system.time() affiche 0 (ou une valeur trÃ¨s proche).\nDe plus, voit quâ€™il y une certaine variabilitÃ© quand relance plusieurs\nfois la commande. Ceci rend la comparaison avec une autre implÃ©mentation (que lâ€™espÃ¨re) plus rapide pour le moins dÃ©licate.Ainsi si souhaite comparer notre code avec la fonction mvtnorm::dmvnorm(),\nne peut pas utiliser system.time() :pourrait se dire quâ€™il faut augmenter la complexitÃ© de notre calcul, mais\nil y mieux : utiliser le package microbenchmark !","code":"\nobs <- matrix(rep(1.96, 2), nrow=2, ncol=1)\nsystem.time(mvnpdf(x=obs, Log=FALSE))##    user  system elapsed \n##   0.001   0.000   0.004\nsystem.time(mvtnorm::dmvnorm(rep(1.96, 2)))##    user  system elapsed \n##   0.003   0.002   0.008"},{"path":"mesurer-et-comparer-des-temps-dexÃ©cution.html","id":"comparer-des-temps-dexÃ©cution-avec-microbenchmark","chapter":"Chapitre 3 Mesurer et comparer des temps dâ€™exÃ©cution","heading":"3.2 Comparer des temps dâ€™exÃ©cution avec microbenchmark()","text":"Comme son nom lâ€™indique, ce package permet justement de comparer des temps\ndâ€™exÃ©cution mÃªme quand ceux-ci sont trÃ¨s faibles. De plus, la fonction\nmicrobenchmark() va rÃ©pÃ©ter un certain nombre de fois lâ€™exÃ©cution des\ncommandes, ce qui va stabiliser son rÃ©sultat.Les deux fonctions mvnpdf() et dmnvorm() Ã©tant capables de prendre en\nentrÃ©e une matrice, peut Ã©galement comparer leurs comportements dans ce\ncas :Il sâ€™est passÃ© un quelque choseâ€¦ Et va diagnostiquer ce problÃ¨me dans le prochain chapitre.","code":"\nlibrary(microbenchmark)\nmb <- microbenchmark(mvtnorm::dmvnorm(rep(1.96, 2)),\n                     mvnpdf(x=matrix(rep(1.96,2)), Log=FALSE),\n                     times=1000L)## Warning in microbenchmark(mvtnorm::dmvnorm(rep(1.96, 2)), mvnpdf(x =\n## matrix(rep(1.96, : less accurate nanosecond times to avoid potential integer\n## overflows\nmb## Unit: microseconds\n##                                           expr    min     lq     mean median\n##                 mvtnorm::dmvnorm(rep(1.96, 2)) 20.254 21.402 23.26033 22.058\n##  mvnpdf(x = matrix(rep(1.96, 2)), Log = FALSE) 18.573 19.680 23.18177 20.213\n##      uq      max neval cld\n##  23.206   98.933  1000   a\n##  21.361 1767.346  1000   a\nn <- 100\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                       expr     min       lq\n##         mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))  23.698  24.9280\n##  mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 267.935 274.9665\n##       mean   median      uq     max neval cld\n##   31.32277  26.4040  30.176 149.076   100  a \n##  285.65848 278.2875 284.376 458.339   100   b"},{"path":"profiler-son-code.html","id":"profiler-son-code","chapter":"Chapitre 4 Profiler son code","heading":"Chapitre 4 Profiler son code","text":"parle de profiling en anglais. Il sâ€™agit de dÃ©terminer ce qui prend\ndu temps dans un code. Le Ã©tant, une fois trouvÃ© le bloc de code qui prend\nle plus de temps dans lâ€™exÃ©cution, dâ€™optimiser uniquement cette brique.Pour obtenir un profiling du code ci-dessous, sÃ©lectionner les lignes de code\ndâ€™intÃ©rÃªt et aller dans le menu â€œProfileâ€ puis â€œProfile Selected Linesâ€. Cela utilise en fait la fonction profvis() du package profvis.OK, get ! ConcatÃ©ner un vecteur au fur et Ã  mesure dans une boucle\nnâ€™est vraiment pas une bonne idÃ©e.","code":"\nn <- 10e4\npdfval <- mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)"},{"path":"profiler-son-code.html","id":"comparaison-avec-une-version-plus-habile-de-mnvpdf","chapter":"Chapitre 4 Profiler son code","heading":"4.1 Comparaison avec une version plus habile de mnvpdf()","text":"ConsidÃ©rons une nouvelle version de mvnpdf(), appelÃ©e mvnpdfsmart(). TÃ©lÃ©charger le fichier puis lâ€™inclure dans votre package.Profiler la commande suivante :effectivement rÃ©solu le problÃ¨me et apprend maintenant de maniÃ¨re plus\nfine ce qui prend du temps dans notre fonction.Pour confirmer que mvnpdfsmart() est effectivement bien plus rapide que\nmvnpdf() peut re-faire une comparaison avec microbenchmark() :Et peut Ã©galement voir si devient compÃ©titif avec dmvnorm() :Il y encore du travailâ€¦","code":"\nn <- 10e4\npdfval <- mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)\nn <- 1000\nmb <- microbenchmark(mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: milliseconds\n##                                                            expr      min\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3.138591\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2.330481\n##        lq     mean   median       uq      max neval cld\n##  3.322681 3.778820 3.437030 3.580571 8.138008   100  a \n##  2.360309 2.447065 2.381362 2.425847 6.387636   100   b\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   43.747\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3147.857\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2308.546\n##         lq       mean   median       uq       max neval cld\n##    51.8445   73.05421   74.251   89.749   117.424   100 a  \n##  3295.1085 3715.51266 3416.387 3522.740  8054.737   100  b \n##  2348.0085 2504.66540 2379.497 2428.163 10087.189   100   c"},{"path":"profiler-son-code.html","id":"comparaison-avec-une-version-optimisÃ©e-dans","chapter":"Chapitre 4 Profiler son code","heading":"4.2 Comparaison avec une version optimisÃ©e dans ","text":"Boris est arrivÃ©, aprÃ¨s de longues recherches et plusieurs tests, Ã  une\nversion optimisÃ©e avec les outils de .Inclure la fonction mvnpdfoptim() dans le package, puis profiler cette\nfonction :Et un petit microbenchmark() :Pour finir peut profiler la fonction dmvnorm() :","code":"\nn <- 10e4\nprofvis::profvis(mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE))\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   43.337\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3154.499\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2314.450\n##  mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 1747.871\n##         lq       mean   median        uq      max neval  cld\n##    53.6075   73.60197   75.235   90.3025  142.680   100 a   \n##  3301.1970 3824.36479 3398.121 3571.4485 8685.276   100  b  \n##  2368.7135 2419.81877 2401.309 2434.4365 3397.875   100   c \n##  1794.3855 1922.38012 1828.580 1863.3475 6635.522   100    d\nn <- 10e5\nlibrary(mvtnorm)\nprofvis::profvis(dmvnorm(matrix(1.96, nrow = n, ncol = 2)))"},{"path":"rcpp-ou-comment-intÃ©grer-facilement-du-code-cdans-un-package.html","id":"rcpp-ou-comment-intÃ©grer-facilement-du-code-cdans-un-package","chapter":"Chapitre 5 Rcpp ou comment intÃ©grer facilement du code C++dans un package ","heading":"Chapitre 5 Rcpp ou comment intÃ©grer facilement du code C++dans un package ","text":"Rcpp (R-C-Plus-Plus) est un package qui facilite lâ€™interface entre C++ et .  est un langage interprÃªtÃ©, ce qui facilite un certain nombre de choses (notamment nous donne accÃ¨s Ã  la console dans laquelle peut Ã©valuer du code Ã  la volÃ©e). NÃ©anmoins, cette facilitÃ© dâ€™utilisation se compense entre autre par des temps de calcul supÃ©rieurs Ã  ceux de langages de plus bas niveau, tels que C, Fortran et C++ (mais qui nÃ©cessitent eux une compilation).dirigera le lecteur curieux vers le livre en ligne\nRcpp everyone de Masaki E. Tsuda, qui\nconstitue une ressource trÃ¨s complÃ¨te pour comprendre lâ€™utilisation de Rcpp en plus de\nlâ€™introduction que lâ€™peut trouver dans le livre Advanced R dâ€™Hadley Wickham 5.","code":""},{"path":"rcpp-ou-comment-intÃ©grer-facilement-du-code-cdans-un-package.html","id":"premiÃ¨re-fonction-en-rcpp","chapter":"Chapitre 5 Rcpp ou comment intÃ©grer facilement du code C++dans un package ","heading":"5.1 PremiÃ¨re fonction en Rcpp","text":"vous de jouer !Afin de rendre votre package prÃªt pour lâ€™utilisation avec Rcpp, commencez par executer la commande\nsuivante :Constatez les changements apportÃ©sComme mentionner dans la console, il faut Ã©galement ajouter les 2 commentaires Roxygen suivants dans la page dâ€™aide globale du package :Nous allons maintenant crÃ©er une premiÃ¨re fonction en Rcpp permettant dâ€™inverser une matrice.\nPour cela, nous allons nous appuyer sur la library C++ Armadillo.\nIl sâ€™agit dâ€™une library dâ€™algÃ¨bre linÃ©aire moderne et simple, hautement optimisÃ©e, et interfacÃ©e\navec  via le package RcppArmadillo.C++ nâ€™est pas un langage trÃ¨s diffÃ©rent de . Les principales diffÃ©rences qui nous concernent :C++est trÃ¨s efficaces pour le boucles (y compris les boucles emboÃ®tÃ©es). Attention :\nil y souvent un sens qui est plus rapide que lâ€™autre (ceci est dÃ» Ã  la maniÃ¨re dont C++ attribue\net parcours la mÃ©moire).C++est trÃ¨s efficaces pour le boucles (y compris les boucles emboÃ®tÃ©es). Attention :\nil y souvent un sens qui est plus rapide que lâ€™autre (ceci est dÃ» Ã  la maniÃ¨re dont C++ attribue\net parcours la mÃ©moire).Chaque commande doit se terminer par un point virgule ;.Chaque commande doit se terminer par un point virgule ;.C++est un langage typÃ© : il faut dÃ©clarer le type de chaque variable avant de pouvoir\nlâ€™utiliser.C++est un langage typÃ© : il faut dÃ©clarer le type de chaque variable avant de pouvoir\nlâ€™utiliser.vous de jouer !CrÃ©ez un nouveau fichier C++ depuis RStudio (via le menu File > New File > C++ File), et enregistrez le dans le dossier src. Prenez le temps de le lire et essayez de comprendre chaque ligne.Compilez et chargez votre package (via le bouton â€œInstall Restartâ€) et essayez dâ€™utiliser la fonction timesTwo() depuis la console.Installez le package RcppArmadillo, et nâ€™oubliez pas de faire les ajouts nÃ©cessaires dans DESCRIPTION (cf.Â usethis::use_rcpp_armadillo())Ã€ lâ€™aide de lâ€™introduction Ã  Rcpp de Hadley Wickham dans son livre Advanced R 6, ainsi que de la documentation du package RcppArmadillo et de celle de la library C++ Armadillo, tentez dâ€™Ã©crire une courte fonction invC en C++ calculant lâ€™inverse dâ€™une matrice.Lorsque vous avez rÃ©ussi Ã  compiler votre fonction invC et quâ€™elle est accessible depuis  crÃ©er une fonction mvnpdf_invC() Ã  partir de lâ€™implÃ©mentation de mvnpdfsmart en remplaÃ§ant uniquement les calculs dâ€™inverse matriciel par un appel Ã  invC.Evaluer le gain en performance de cette nouvelle implÃ©mentation mvnpdf_invC.","code":"```r\nusethis::use_rcpp()\n``````r\n#' @useDynLib mypkgr\n#' @importFrom Rcpp sourceCpp, .registration = TRUE\nNULL\n```\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdf_invC(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb\n## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   44.198\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3150.358\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2329.251\n##  mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 1763.984\n##  mvnpdf_invC(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2316.746\n##        lq       mean   median       uq      max neval  cld\n##    55.842   75.18457   77.203   90.897  122.795   100 a   \n##  3287.462 3530.78511 3356.649 3490.576 9381.292   100  b  \n##  2363.015 2554.23973 2390.361 2435.851 7216.287   100   c \n##  1810.499 1979.80062 1848.157 1889.198 7138.059   100    d\n##  2353.584 2499.20133 2380.337 2433.658 6020.686   100   c\nprofvis::profvis(mvnpdfoptim(x=matrix(1.96, \n    nrow = 2, ncol = 1000), Log=FALSE))## Error in parse_rprof_lines(lines, expr_source): No parsing data available. Maybe your function was too fast?\nprofvis::profvis(mvnpdfoptim(x=matrix(1.96, \n    nrow = 100, ncol = 1000), Log=FALSE))"},{"path":"rcpp-ou-comment-intÃ©grer-facilement-du-code-cdans-un-package.html","id":"optimisation-grÃ¢ce-Ã -c","chapter":"Chapitre 5 Rcpp ou comment intÃ©grer facilement du code C++dans un package ","heading":"5.2 Optimisation grÃ¢ce Ã  C++","text":"En rÃ¨gle gÃ©nÃ©rale, ne gagne pas beaucoup en temps de calcul en remplaÃ§ant une fonction \noptimisÃ©e par une fonction en C++. En effet, la plupart des fonctions de base de  sâ€™appuie en\nrÃ©alitÃ© dÃ©jÃ  sur des routines C ou Fortran bien optimisÃ©e. Le gain se limite alors simplement\nÃ  la suppression des vÃ©rifications des arguments et de la gestion des diffÃ©rents types.vous de jouer !Ã€ partir de mvnpdfsmart, proposez une implÃ©mentation completement en C++ du calcul\nde densitÃ© de la loi Normale multivariÃ©e mvnpdfC().Evaluer le gain en performance de cette nouvelle implÃ©mentation mvnpdfCVous pouvez tÃ©lÃ©charger notre proposition de mvnpdfC.cpp ici.Pour un gain (relativement faible small) supplÃ©mentaire de temps de calcul (au prix dâ€™un code plus difficile Ã  lire), vous pouvez jettez un oeil Ã  notre implÃ©mentation optimizÃ©e utilisant C++ et Armadillo dans le fichier mvnpdfoptimC.cpp.Ã€ noter que vous pouvez utiliser des fonctions Rcpp en dehors de lâ€™architecture\ndâ€™un package grÃ¢ce Ã  la fonction Rcpp::sourceCpp(). Mais, comme nous lâ€™avons vu,\nil est prÃ©fÃ©rable de gÃ©rer tous ses codes sous la forme de package : il est\ndonc peu probable que vous en ayez besoin !","code":"\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdf_invC(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmartC(x=matrix(1.96, nrow = 2, ncol = n), mean = rep(0, 2), varcovM = diag(2), Log=FALSE),\n                     mvnpdfoptimC(x=matrix(1.96, nrow = 2, ncol = n), mean = rep(0, 2), varcovM = diag(2), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                                                                       expr\n##                                                         mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))\n##                                                  mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                             mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                             mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                             mvnpdf_invC(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##  mvnpdfsmartC(x = matrix(1.96, nrow = 2, ncol = n), mean = rep(0,      2), varcovM = diag(2), Log = FALSE)\n##  mvnpdfoptimC(x = matrix(1.96, nrow = 2, ncol = n), mean = rep(0,      2), varcovM = diag(2), Log = FALSE)\n##       min        lq       mean    median        uq      max neval  cld\n##    44.362   57.2360   75.42319   77.8590   88.7035  113.365   100 a   \n##  3173.359 3297.3840 3516.53966 3380.4295 3508.6980 8638.864   100  b  \n##  2335.155 2370.7840 2451.90824 2397.0035 2427.5690 6993.452   100   c \n##  1765.337 1810.7240 2002.75488 1836.4720 1889.8950 6392.761   100    d\n##  2321.871 2358.7710 2565.19452 2385.4620 2421.3780 7517.391   100   c \n##    51.496   55.4320   61.39750   60.3725   65.6615   88.806   100 a   \n##    35.834   38.9295   45.58872   43.9315   50.8810  112.873   100 a"},{"path":"rcpp-ou-comment-intÃ©grer-facilement-du-code-cdans-un-package.html","id":"annexe-5.1-loptimisation-prÃ©maturÃ©e-nest-pas-une-bonne-idÃ©e","chapter":"Chapitre 5 Rcpp ou comment intÃ©grer facilement du code C++dans un package ","heading":"Annexe 5.1 : lâ€™optimisation prÃ©maturÃ©e nâ€™est pas une bonne idÃ©e","text":"Chambers, Software Data Analysis: Programming R, Springer, 2008 :â€œIncluding additional C code serious step, added dangers\noften substantial amount programming debugging required.\ngood reason.â€","code":""},{"path":"parallÃ©lisation-du-code-r.html","id":"parallÃ©lisation-du-code-r","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"Chapitre 6 ParallÃ©lisation du code R","text":"","code":""},{"path":"parallÃ©lisation-du-code-r.html","id":"introduction-Ã -lexecution-parallÃ¨le-sous-r","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.1 Introduction Ã  lâ€™execution parallÃ¨le sous R","text":"En dehors de lâ€™optimisation du code et des algorithmes, une autre faÃ§on\ndâ€™obtenir un code performant est de tirer profit des architectures parallÃ¨les\ndes ordinateurs modernes. Il sâ€™agit alors de parallÃ©liser son code afin de\nfaire des opÃ©rations simultanÃ©es sur des parties distinctes dâ€™un mÃªme problÃ¨me,\nen utilisant diffÃ©rent cÅ“urs de calcul. ne rÃ©duit pas le temps de calcul\ntotal nÃ©cessaire, mais lâ€™ensemble des opÃ©rations sâ€™exÃ©cute plus rapidement.Il existe un nombre non nÃ©gligeable dâ€™algorithmes qui sont dâ€™un â€œparallÃ©lisme\nembarrassantâ€, câ€™est-Ã -dire dont les calculs peuvent se dÃ©composer en plusieurs\nsous-calculs indÃ©pendants. En statistique, il est ainsi souvent facile et direct\nde parallÃ©liser selon les diffÃ©rentes observations ou selon les diffÃ©rentes\ndimensions. Typiquement, il sâ€™agit dâ€™opÃ©rations que lâ€™peut Ã©crire sous la\nforme de boucle dont les opÃ©rations sont indÃ©pendantes dâ€™une itÃ©ration de la\nboucle Ã  lâ€™autre.Les opÃ©rations nÃ©cessaires pour lâ€™Ã©tablissement dâ€™un code parallÃ¨le sont les suivantes :DÃ©marrer \\(m\\) processus â€œtravailleursâ€ (.e.Â cÅ“urs de calcul) et les initialiserDÃ©marrer \\(m\\) processus â€œtravailleursâ€ (.e.Â cÅ“urs de calcul) et les initialiserEnvoyer les fonctions et donnÃ©es nÃ©cessaires pour chaque tache aux travailleursEnvoyer les fonctions et donnÃ©es nÃ©cessaires pour chaque tache aux travailleursSÃ©parer les taches en \\(m\\) opÃ©rations dâ€™envergure similaire et les envoyer aux travailleursSÃ©parer les taches en \\(m\\) opÃ©rations dâ€™envergure similaire et les envoyer aux travailleursAttendre que tous les travailleurs aient terminer leurs calculs et obtenir leurs rÃ©sultatsAttendre que tous les travailleurs aient terminer leurs calculs et obtenir leurs rÃ©sultatsRassembler les rÃ©sultats des diffÃ©rents travailleursRassembler les rÃ©sultats des diffÃ©rents travailleursArrÃªter les processus travailleursArrÃªter les processus travailleursSelon les plateformes, plusieurs protocoles de communications sont disponibles\nentre les cÅ“urs. Sous les systÃ¨mes UNIX, le protocole Fork est le plus\nutilisÃ©, mais il nâ€™est pas disponible sous Windows oÃ¹ utilise\nprÃ©fÃ©rentiellement le protocole PSOCK. Enfin, pour les architecture de calcul\ndistribuÃ©e oÃ¹ les cÅ“urs ne se trouvent pas nÃ©cessairement sur le mÃªme processeur\nphysique, utilise gÃ©nÃ©ralement le protocole MPI. Lâ€™avantage des packages\nfuture et future.apply est que le mÃªme code pourra Ãªtre exÃ©cutÃ© quelque soit\nla configuration matÃ©rielle.Il existe un nombre important de packages et dâ€™initiatives permettant de faire\ndu calcul en R. Depuis R 2.14.0, le package\nparallel\nest inclus directement dans R et permet de dÃ©marrer et dâ€™arrÃªter un â€œclusterâ€\nde plusieurs processus travailleur (Ã©tape 1 et 6). En plus du package\nparallel, va donc utiliser le package future qui permet de gÃ©rer les\nprocessus travailleurs et la communication et lâ€™articulation avec le package\nfuture.applyqui permet lui de gÃ©rer le dialogue avec les travailleurs (envois,\nrÃ©ception et rassemblement des rÃ©sultats - Ã©tapes 2, 3, 4 et 5).","code":""},{"path":"parallÃ©lisation-du-code-r.html","id":"premiÃ¨re-fonction-parallÃ¨le-en-r","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.2 PremiÃ¨re fonction parallÃ¨le en R","text":"Ã€ vous de jouer !Commencez par Ã©crire une fonction simple qui calcule le logarithme de \\(n\\)\nnombres:DÃ©terminez combien de coeurs sont disponibles sur votre marchine grÃ¢ce Ã \nla fonction future::availableCores().DÃ©terminez combien de coeurs sont disponibles sur votre marchine grÃ¢ce Ã \nla fonction future::availableCores().Ã€ lâ€™aide de la fonction future::plan(multisession(workers = XX)),\ndÃ©clarez un â€œplanâ€ de calculs parallÃ¨les sur votre ordinateur (en prenant garde\nÃ  laisser un coeur disponible pour traiter les autres processus).Ã€ lâ€™aide de la fonction future::plan(multisession(workers = XX)),\ndÃ©clarez un â€œplanâ€ de calculs parallÃ¨les sur votre ordinateur (en prenant garde\nÃ  laisser un coeur disponible pour traiter les autres processus).Ã€ lâ€™aide dâ€™une fonction de type apply future.apply::future_*apply(),\ncalculez le log des \\(n\\) nombres en parallÃ¨le et concatÃ©nez les rÃ©sultats dans un\nvecteur.Ã€ lâ€™aide dâ€™une fonction de type apply future.apply::future_*apply(),\ncalculez le log des \\(n\\) nombres en parallÃ¨le et concatÃ©nez les rÃ©sultats dans un\nvecteur.Comparez le temps dâ€™Ã©xecution avec celui dâ€™une fonction sÃ©quentielle\nsur les 100 premiers entiers, grÃ¢ce Ã  la commande :microbenchmark(log_par(1:100), log_seq(1:100), times=10)Comparez le temps dâ€™Ã©xecution avec celui dâ€™une fonction sÃ©quentielle\nsur les 100 premiers entiers, grÃ¢ce Ã  la commande :microbenchmark(log_par(1:100), log_seq(1:100), times=10)La version parallÃ¨le tourne beaucoup plus lentementâ€¦ Car en fait, si les\ntÃ¢ches individuelles sont trop rapides, R va passer plus de temps Ã \ncommuniquer avec les cÅ“urs, quâ€™Ã  faire les calculs effectifs.Il faut quâ€™une itÃ©ration de la boucle soit relativement longue pour que le\ncalcul parallÃ¨le apporte un gain en temps de calcul !En augmentant \\(n\\), observe une rÃ©duction de la diffÃ©rence entre les 2\nimplÃ©mentations (le temps de calcul en parallÃ¨le augmente trÃ¨s lentement comparÃ©\nÃ  lâ€™augmentation de celui de la fonction sÃ©quentielle).NB : les itÃ©rateurs dâ€™itertools sont trÃ¨s performants mais ne peuvent\nservir que lorsque le code Ã  lâ€™intÃ©rieur de future_*apply() est vectorisÃ© (il\nest toujours possible de vectoriser le code Ã  lâ€™intÃ©rieur, par exemple avec une\nfonction de type apply). Ils minimisent le nombre de communication entre les\ncoeurs.","code":"\nlibrary(microbenchmark)\nlibrary(future.apply)\n\nlog_seq <- function(x){\n  # try this yourself (spoiler alert: it is quite long...):\n  # res <- numeric(length(x))\n  # for(i in 1:length(x)){\n  #   res[i] <- log(x[i])\n  # }\n  # return(res)\n  return(log(x))\n}\n\nlog_par <- function(x){\n  res <- future_sapply(1:length(x), FUN = function(i) {\n    log(x[i])\n  })\n  return(res)\n}\n\nplan(multisession(workers = 3))\nmb <- microbenchmark(log_par(1:100), log_seq(1:100), times = 50)"},{"path":"parallÃ©lisation-du-code-r.html","id":"parallÃ©lisation-efficace","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.3 ParallÃ©lisation efficace","text":"va maintenant se pencher sur un autre cas dâ€™utilisation. Imaginons que lâ€™\nait un grand tableau de donnÃ©es de taille comportant 10 observations pour 100\n000 variables (e.g.Â des mesures de gÃ©nomique), et que lâ€™veuille calculer la\nmÃ©diane pour chacune de ces variables.Pour un utilisateur averti de R, une telle opÃ©ration se programme facilement\nÃ  lâ€™aide de la fonction apply :En rÃ©alitÃ©, une boucle nâ€™est pas plus lente Ã  condition dâ€™Ãªtre bien\nprogrammÃ©e :Ã€ vous de jouer !\nEssayez dâ€™amÃ©liorer encore ce temps de calcul en parallÃ©lisant :ParallÃ©lisez le calcul de la mÃ©diane de chacune des 100 000 variables.\nObserve-t-un gain en temps de calcul ?ParallÃ©lisez le calcul de la mÃ©diane de chacune des 100 000 variables.\nObserve-t-un gain en temps de calcul ?Proposez une implÃ©mentation alternative grÃ¢ce Ã  la fonction\nitertools::isplitIndices() qui permet de sÃ©parer vos donnÃ©es (les \\(n\\) nombres)\nen autant de groupes que vous avez de coeurs. Comparez Ã  nouveau les temps de\ncalcul.Proposez une implÃ©mentation alternative grÃ¢ce Ã  la fonction\nitertools::isplitIndices() qui permet de sÃ©parer vos donnÃ©es (les \\(n\\) nombres)\nen autant de groupes que vous avez de coeurs. Comparez Ã  nouveau les temps de\ncalcul.","code":"\nx <- matrix(rnorm(1e6), nrow = 10)\ndim(x)## [1]     10 100000\ncolmedian_apply <- function(x){\n  return(apply(x, 2, median))\n}\nsystem.time(colmedian_apply(x))##    user  system elapsed \n##   1.659   0.009   1.673\ncolmedian_for <- function(x){\n  ans <- rep(0, ncol(x)) \n  for (i in 1:ncol(x)) {\n    ans[i] <- median(x[, i]) \n  }\n  return(ans)\n}\nsystem.time(colmedian_for(x))##    user  system elapsed \n##   1.497   0.006   1.504\ncolmedian_par <- function(x){\n  res <- future_sapply(1:ncol(x), FUN = function(i) {\n          median(x[, i])\n    })\n  return(res)\n}\nplan(multisession(workers = 3))\nsystem.time(colmedian_par(x))##    user  system elapsed \n##   0.129   0.017   0.905\ncolmedian_parIter <- function(x, ncores = 1){\n  iter <- itertools::isplitIndices(n = ncol(x), chunks = ncores)\n  res <- future_sapply(iter, FUN = function(i) {\n          apply(x[, i], 2, median)\n    })\n  return(unlist(res))\n}\nsystem.time(colmedian_parIter(x, ncores = 3))##    user  system elapsed \n##   0.066   0.012   0.696\nmb <- microbenchmark(colmedian_apply(x), \n                     colmedian_for(x),\n                     colmedian_par(x),\n                     colmedian_parIter(x, ncores = 3), times = 10)\nmb## Unit: milliseconds\n##                              expr       min        lq      mean    median\n##                colmedian_apply(x) 1518.1346 1541.9574 1568.2892 1568.3977\n##                  colmedian_for(x) 1474.2957 1495.8790 1531.8657 1518.1458\n##                  colmedian_par(x)  708.0211  712.8069  731.6481  719.7465\n##  colmedian_parIter(x, ncores = 3)  606.6464  619.0144  639.6004  632.1714\n##         uq       max neval cld\n##  1578.2346 1633.0845    10 a  \n##  1548.6421 1648.4490    10 a  \n##   725.2583  854.5031    10  b \n##   648.3523  724.2790    10   c"},{"path":"parallÃ©lisation-du-code-r.html","id":"les-itÃ©rateurs","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.3.1 Les itÃ©rateurs","text":"Le package itertools permet de sÃ©parer facilement des donnÃ©es ou des\ntaches (Ã©tape 3) tout en minimisant les communications avec les diffÃ©rents\ntravailleurs. Il sâ€™appuie sur une implÃ©mentation des itÃ©rateurs en R.\nSon utilisation nÃ©cessite nÃ©anmoins de vectoriser le code Ã  lâ€™intÃ©rieur de\nfuture_*apply(). ExpÃ©rimentez avec le petit code ci-dessous :","code":"\nmyiter <- itertools::isplitIndices(n = 30, chunks = 3)\n\n# Une premiÃ¨re fois\niterators::nextElem(myiter)##  [1]  1  2  3  4  5  6  7  8  9 10\n# Une deuxiÃ¨me fois... Oh ?!\niterators::nextElem(myiter)##  [1] 11 12 13 14 15 16 17 18 19 20\n# Encore !\niterators::nextElem(myiter)##  [1] 21 22 23 24 25 26 27 28 29 30\n# Encore ?\niterators::nextElem(myiter)## Error: StopIteration"},{"path":"parallÃ©lisation-du-code-r.html","id":"les-autres-plans-de-calculs-parallÃ¨le","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.3.2 Les autres â€œplansâ€ de calculs parallÃ¨le","text":"Pour exÃ©cuter votre code (exactement le mÃªme code, câ€™est un des avantages\ndu packages de la famille future*), vous devez rÃ©gler un â€œplanâ€ de calculs :sur un ordinateur (ou un unique serveur de calcul) sous Unix (Linux, Mac OS),\nvous pouvez utiliser plan(multicore(workers = XX)) qui est souvent plus\nperformant. Le plan multisession fonctionne toujours.sur un ordinateur (ou un unique serveur de calcul) sous Unix (Linux, Mac OS),\nvous pouvez utiliser plan(multicore(workers = XX)) qui est souvent plus\nperformant. Le plan multisession fonctionne toujours.sur un cluster de calculs (type Avakas Ã  Bordeaux), nous renvoyons au package\nfuture.batchtoolssur un cluster de calculs (type Avakas Ã  Bordeaux), nous renvoyons au package\nfuture.batchtools","code":""},{"path":"parallÃ©lisation-du-code-r.html","id":"parallÃ©lisation-dans-notre-exemple-fil-rouge","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.4 ParallÃ©lisation dans notre exemple fil rouge","text":"Ã€ vous de jouer !Ã€ partir de la fonction mvnpdfoptim() et/ou mvnpdfsmart(), proposez\nune implÃ©mentation parallÃ©lisant les calculs sur les observations (colonnes de \\(x\\))Ã€ partir de la fonction mvnpdfoptim() et/ou mvnpdfsmart(), proposez\nune implÃ©mentation parallÃ©lisant les calculs sur les observations (colonnes de \\(x\\))Comparez les temps de calcul sur 10 000 observationsComparez les temps de calcul sur 10 000 observationsNotre proposition dâ€™implementation pour mvnpdfoptim_par est tÃ©lÃ©chargeable ici.","code":"\nplan(multisession(workers = 3))\nn <- 10000\nmb <- microbenchmark::microbenchmark(\n  mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n  mypkgr::mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n  mypkgr::mvnpdfoptim_par(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n  mypkgr::mvnpdfoptim_parIter(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE, ncores = 3),\n  times=20L)\nmb## Unit: microseconds\n##                                                                                             expr\n##                                               mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))\n##                           mypkgr::mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                  mypkgr::mvnpdfoptim_par(x = matrix(1.96, nrow = 2, ncol = n),      Log = FALSE)\n##  mypkgr::mvnpdfoptim_parIter(x = matrix(1.96, nrow = 2, ncol = n),      Log = FALSE, ncores = 3)\n##        min         lq       mean    median       uq        max neval cld\n##    231.035   277.0985   298.4574   293.601   309.14    413.239    20  a \n##  17897.976 18047.4005 19202.7293 18361.993 19917.92  22561.972    20  a \n##  40055.852 41174.2910 53677.7986 41733.715 43496.14 270043.138    20   b\n##  41021.648 41606.4925 43428.8953 42418.005 44911.07  49199.057    20   b"},{"path":"parallÃ©lisation-du-code-r.html","id":"conclusion","chapter":"Chapitre 6 ParallÃ©lisation du code R","heading":"6.5 Conclusion","text":"La parallÃ©lisation permet de gagner du temps, mais il faut dâ€™abord bien\noptimiser son code. Quand parallÃ©lise un code, le gain sur la durÃ©e\ndâ€™exÃ©cution dÃ©pend avant tout du ratio entre le temps de communication et le\ntemps de calcul effectif pour chaque tache.","code":""},{"path":"take-home-message.html","id":"take-home-message","chapter":"Chapitre 7 Take Home message","heading":"Chapitre 7 Take Home message","text":"FAITES DES PACKAGESFAITES DES PACKAGESutilisez git, au moins pour vous en localutilisez git, au moins pour vous en localsi besoin (.e.Â aprÃ¨s optimisation du code R lui mÃªme), nâ€™ayez pas peur de vous tourner vers Rcpp et/ou la\nparallÃ©lisation de votre codesi besoin (.e.Â aprÃ¨s optimisation du code R lui mÃªme), nâ€™ayez pas peur de vous tourner vers Rcpp et/ou la\nparallÃ©lisation de votre code","code":""},{"path":"rÃ©fÃ©rences.html","id":"rÃ©fÃ©rences","chapter":"RÃ©fÃ©rences","heading":"RÃ©fÃ©rences","text":"Les livres en ligne dâ€™Hadley Wickham sont vraiment excellents et contiennent beaucoup de complÃ©ments et de dÃ©tails par rapport Ã  tout ce que lâ€™traitÃ© durant cette formation :le site sur la construction de package R packages.le site sur la construction de package R packages.le site Advanced R pour tout ce qui concerne lâ€™optimisation, Rcpp, ou encore le calcul parallÃ¨le.le site Advanced R pour tout ce qui concerne lâ€™optimisation, Rcpp, ou encore le calcul parallÃ¨le.le site R Data Science est Ã©galement trÃ¨s complet et comprend des chapitres sur la gestion des structures de donnÃ©es dans , mais aussi la modÃ©lisation ainsi que des Ã©lÃ©ments sur les graphiques et Quarto.le site R Data Science est Ã©galement trÃ¨s complet et comprend des chapitres sur la gestion des structures de donnÃ©es dans , mais aussi la modÃ©lisation ainsi que des Ã©lÃ©ments sur les graphiques et Quarto.le livre en ligne Rcpp everyone de Masaki E. Tsuda est Ã©galement trÃ¨s bien.le livre en ligne Rcpp everyone de Masaki E. Tsuda est Ã©galement trÃ¨s bien.","code":""}]
