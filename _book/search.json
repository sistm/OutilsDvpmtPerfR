[{"path":"index.html","id":"présentation-de-la-formation","chapter":"Présentation de la formation","heading":"Présentation de la formation","text":"Le principal de cette formation est de vous donner des outils pour\nfaciliter le développement de code (performant) avec . L’aspect “performance”\narrivera dans un deuxième temps, et les premiers outils présentés sont\négalement très utiles dans des situations ne faisant pas intervenir de temps\nde calculs importants.Nous allons centrer la présentation de ces outils de développement autour\nde la notion de package. Vous connaissez déjà cette notion, car vous avez\ndéjà installer des packages depuis le CRAN par exemple. Vous savez également\nque c’est le moyen le plus standard dans  pour\npartager et mettre à disposition du code.\nNous allons vous montrer que le package est également un excellent outil pour\ndévelopper le code.Nous allons adopter le plan suivant :Build R package useful tool code developmentLeverage git tracking changes, GitHub sharing code, collaborative development, automating tests package broadcast companion websiteLeverage git tracking changes, GitHub sharing code, collaborative development, automating tests package broadcast companion websiteConstruire un package  comme outils de développement de codeConstruire un package  comme outils de développement de codeUtiliser git pour tracer les changements, et GitHub pour partager son code, le développement collaboratif, automatiser les tests dans un package et diffuser un site web d’accompagnementUtiliser git pour tracer les changements, et GitHub pour partager son code, le développement collaboratif, automatiser les tests dans un package et diffuser un site web d’accompagnementMesurer le temps de calculMesurer le temps de calculProfiler le codeProfiler le codeUtiliser Rcpp pour optimiser ce qui doit l’êtreUtiliser Rcpp pour optimiser ce qui doit l’êtreParalléliser facilement le codeParalléliser facilement le code","code":""},{"path":"index.html","id":"logiciels-et-librairies-nécessaires-à-la-formation","chapter":"Présentation de la formation","heading":"Logiciels et librairies nécessaires à la formation","text":"Afin de suivre cette formation, il est nécessaire de disposer des logiciels suivants :la dernière version de  (https://cloud.r-project.org/)la dernière version de  (https://cloud.r-project.org/)la dernière version de RStudio (https://posit.co/download/rstudio-desktop/#download)la dernière version de RStudio (https://posit.co/download/rstudio-desktop/#download)un compilateur C++ (tel que gcc ou clang - natif sous les système UNIX,\npour les utilisateurs Windows nous recommandons l’installation de\nRtools, pour les\nutilisateurs Mac il peut être nécessaire d’installer les outils de\ndéveloppement Apple comme indiqué\nici)un compilateur C++ (tel que gcc ou clang - natif sous les système UNIX,\npour les utilisateurs Windows nous recommandons l’installation de\nRtools, pour les\nutilisateurs Mac il peut être nécessaire d’installer les outils de\ndéveloppement Apple comme indiqué\nici)les packages  suivants : devtools, future.apply, itertools, microbenchmark, mvtnorm, profvis, Rcpp, RcppArmadillo, roxygen2, testthat, usethisles packages  suivants : devtools, future.apply, itertools, microbenchmark, mvtnorm, profvis, Rcpp, RcppArmadillo, roxygen2, testthat, usethisle logiciel gitle logiciel gitle client GitHub Desktople client GitHub Desktop","code":""},{"path":"index.html","id":"pré-requis","chapter":"Présentation de la formation","heading":"Pré-requis","text":"Afin de pouvoir suivre cette formation correctement vous devez être à l’aise avec les aspects suivants :la programation avec  dans l’environnement de développement RStudioécriture de fonctions en structure de contrôle, en particulier les boucles forle calcul de la densité d’une loi normale multivariée","code":""},{"path":"construire-un-package.html","id":"construire-un-package","chapter":"Chapitre 1 Construire un package ","heading":"Chapitre 1 Construire un package ","text":"Nous présentons ici comment construire un package efficacement à l’aide d’outils\ngraphiques présents dans RStudio et du package devtools.Le support de référence sur ce sujet est le livre\nR packages1 d’Hadley Wickham & Jennifer Bryan, disponible en ligne.","code":""},{"path":"construire-un-package.html","id":"initialiser-un-package","chapter":"Chapitre 1 Construire un package ","heading":"1.1 Initialiser un package","text":"Une manière simple, et intégrée à RStudio, pour initialiser un package est d’executer les étapes suivantes :👉 À vous de jouer (déjà)!créer un nouveau projet (menu déroulant en haut à gauche dans RStudio)créer un nouveau projet (menu déroulant en haut à gauche dans RStudio)choisir “New Directory”choisir “New Directory”choisir “R package using devtools” (s’il n’est pas disponible c’est que le package devtools n’est pas installer et dans ce cas peut alors choisir “R package” – la différence étant qu’avec “R package”, il faudra supprimer des fichiers créés automatiquement mais inutiles)choisir “R package using devtools” (s’il n’est pas disponible c’est que le package devtools n’est pas installer et dans ce cas peut alors choisir “R package” – la différence étant qu’avec “R package”, il faudra supprimer des fichiers créés automatiquement mais inutiles)donner un nom au package, par exemple mypkgr.donner un nom au package, par exemple mypkgr.récupère alors la structure minimale pour un package , à savoir :un fichier DESCRIPTION dont les parties Title, Version, Authors@R et\nDescription sont à éditer (d’autres parties pourront être éditer voire\nmême ajouter de manière automatique, comme nous le verrons plus loin)un fichier DESCRIPTION dont les parties Title, Version, Authors@R et\nDescription sont à éditer (d’autres parties pourront être éditer voire\nmême ajouter de manière automatique, comme nous le verrons plus loin)un fichier NAMESPACE qui sera édité automatiquement ultérieurementun fichier NAMESPACE qui sera édité automatiquement ultérieurementun dossier R dans lequel va ajouter des fichiers de scripts un dossier R dans lequel va ajouter des fichiers de scripts devtools ajoute également trois fichiers facultatifs :.gitignore, relatif à git, outils de contrôle de version que nous verrons en détails\ndans la partie sur GitHub.gitignore, relatif à git, outils de contrôle de version que nous verrons en détails\ndans la partie sur GitHubmypkgr.Rproj qui est un fichier spécifique de Rstudio, et permet de définir\nles caractéristiques et préférences du projet que nous venons de créermypkgr.Rproj qui est un fichier spécifique de Rstudio, et permet de définir\nles caractéristiques et préférences du projet que nous venons de créer.Rbuildignore qui permet d’ignorer certains fichiers au moment où \nconstruira le package un peu plus loin (par exemple, le fichier mypkgr.Rproj\nne doit pas être inclus dans le package).Rbuildignore qui permet d’ignorer certains fichiers au moment où \nconstruira le package un peu plus loin (par exemple, le fichier mypkgr.Rproj\nne doit pas être inclus dans le package)","code":""},{"path":"construire-un-package.html","id":"ajouter-une-fonction-exemple-fil-rouge","chapter":"Chapitre 1 Construire un package ","heading":"1.2 Ajouter une fonction : exemple fil rouge","text":"Nous vous proposons de coder la fonction suivante, que nous reprendrons tout au\nlong de la formation :Nous souhaitons calculer la valeur de la densité d’une loi normale multivariée\nsur \\(\\mathbb{R}^p\\) en \\(n\\) points. Notre fonction doit pouvoir s’appliquer pour\nn’importe quelle loi normale multivariée (vecteur de moyennes \\(\\boldsymbol \\mu\\) dans\n\\(\\mathbb{R}^p\\) et matrice de variance-covariance \\(\\boldsymbol\\Sigma\\) d’ordre de \\(p\\) quelconques),\net souhaite pouvoir calculer toutes les valeurs de la densité évaluées\nsur les \\(n\\) points \\(\\boldsymbol \\mathbf{x}\\) en un seul appel de la fonction.Pour rappel, la fonction de densité d’une loi normale multivariée s’écrit :\n\\[\\displaystyle (2\\pi )^{-p/2}\\det({\\boldsymbol {\\Sigma }})^{-1/2}\\,\\exp \\left(-{\\frac {1}{2}}(\\mathbf {x} -{\\boldsymbol {\\mu }})^{\\mathsf {T}}{\\boldsymbol {\\Sigma }}^{-1}(\\mathbf {x} -{\\boldsymbol {\\mu }})\\right)\\]Vous devez donc créer une fonction mvnpdf() dans un fichier nommé mvnpdf.R\ndans le dossier  du package, qui :prend en arguments :\nx une matrice, à \\(n\\) colonnes (les observations) et \\(p\\) lignes\nmean un vecteur de moyennes\nvarcovM une matrice de variance-covariance\nLog un paramètre logique valant TRUE par défaut\nprend en arguments :x une matrice, à \\(n\\) colonnes (les observations) et \\(p\\) lignesx une matrice, à \\(n\\) colonnes (les observations) et \\(p\\) lignesmean un vecteur de moyennesmean un vecteur de moyennesvarcovM une matrice de variance-covariancevarcovM une matrice de variance-covarianceLog un paramètre logique valant TRUE par défautLog un paramètre logique valant TRUE par défautrenvoie une liste contenant la matrice x ainsi qu’un vecteur des images\ndes points de x par la fonction de densité de la variable aléatoire de loi\nnormale multivariée considérée.renvoie une liste contenant la matrice x ainsi qu’un vecteur des images\ndes points de x par la fonction de densité de la variable aléatoire de loi\nnormale multivariée considérée.👉 À vous de jouer !Voici une proposition de fonction que vous pouvez télécharger\nici. ⚠️ ATTENTION ! Si vous cliquez trop vite sur le lien ci-dessous, cela invalidera votre participation à la formation !Pour des conseils lors de la rédaction de code, voir le chapitre\nR code dans R packages (2023) de Wickham & Bryan2.","code":""},{"path":"construire-un-package.html","id":"documenter-une-fonction","chapter":"Chapitre 1 Construire un package ","heading":"1.3 Documenter une fonction","text":"Il est important de bien documenter votre code. Tout projet au moins 2\ndéveloppeurs :vousvousvous dans 6 moisvous dans 6 moisPar égard à votre “futur vous”, soyez sympas et prenez le temps de documenter\nvotre code 😉 !Nous vous conseillons vivement d’utiliser le package roxygen2 pour documenter\nvos packages. L’avantage principal étant d’avoir l’aide d’une fonction dans\nle même fichier que le code définissant cette fonction.👉 À vous de jouer !Commencer par insérer le squelette de l’aide grâce à “Insert Roxygen\nSkeleton” situé dans le menu “Code” ou le sous-menu Baguette magique dans\nla fenêtre de script.Commencer par insérer le squelette de l’aide grâce à “Insert Roxygen\nSkeleton” situé dans le menu “Code” ou le sous-menu Baguette magique dans\nla fenêtre de script.Compléter la documentation en renseignant :\nle titre de la fonction (première ligne)\nla description de ce que fait la fonction (deuxième paragraphe)\nsi vous renseignez un troisième paragraphe, cette partie ira dans la section “Details” de la page d’aide\nla signification des paramètres\nla sortie, après la balise @return\nCompléter la documentation en renseignant :le titre de la fonction (première ligne)le titre de la fonction (première ligne)la description de ce que fait la fonction (deuxième paragraphe)la description de ce que fait la fonction (deuxième paragraphe)si vous renseignez un troisième paragraphe, cette partie ira dans la section “Details” de la page d’aidesi vous renseignez un troisième paragraphe, cette partie ira dans la section “Details” de la page d’aidela signification des paramètresla signification des paramètresla sortie, après la balise @returnla sortie, après la balise @returnGénérer la documentation à l’aide de “Document” dans le menu “” de l’onglet “Build” (ou Ctrl+Shift+D ou devtools::document()). L’effet de cette commande est multiple :\nun dossier man été créé et à l’intérieur, un fichier mvnpdf.Rd été créé et contient les informations de l’aide de la fonction\nle fichier NAMESPACE été modifié\nGénérer la documentation à l’aide de “Document” dans le menu “” de l’onglet “Build” (ou Ctrl+Shift+D ou devtools::document()). L’effet de cette commande est multiple :un dossier man été créé et à l’intérieur, un fichier mvnpdf.Rd été créé et contient les informations de l’aide de la fonctionun dossier man été créé et à l’intérieur, un fichier mvnpdf.Rd été créé et contient les informations de l’aide de la fonctionle fichier NAMESPACE été modifiéle fichier NAMESPACE été modifiéEn cas de bug ou par curiosité ET une fois que vous avez terminé vous pouvez consulter cette proposition.Pour plus de détails sur la documentation de package et les balises\nroxygen2, voir la page\nObject documentation du site d’Hadley.Finissons par évoquer une fonction du package usethis qui initialise une\npage d’aide pour le package dans son ensemble :La page d’aide générée sera alors accessible, une fois le package installé,\nvia :","code":"\nusethis::use_package_doc()\n?mypkgr"},{"path":"construire-un-package.html","id":"tester-le-package-de-manière-intéractive","chapter":"Chapitre 1 Construire un package ","heading":"1.4 Tester le package de manière intéractive","text":"Pour tester le package, vous devez le charger dans R à l’aide de :\ndans l’onglet “Build”, le menu “” puis “Load ” (ou Ctrl+Shift+L ou\ndevtools::load_all()).Vous pouvez alors utiliser votre package directement dans R : consulter\nl’aide de la fonction avec ?mvnpdf et par exemple exécuter les commandes renseignées dans la section exemple de cette page d’aide.Ainsi, lors du développement, vous pouvez :Ajouter/Modifier le code RAjouter/Modifier le code RRe-charger le package Ctrl+Shift+LRe-charger le package Ctrl+Shift+LEssayer dans la consoleEssayer dans la consoleEt ainsi de suite…Et ainsi de suite…","code":"\n?mvndpf"},{"path":"construire-un-package.html","id":"tester-le-package-de-manière-automatique","chapter":"Chapitre 1 Construire un package ","heading":"1.5 Tester le package de manière automatique","text":"Pour initialiser la fonctionnalité de tests automatiques dans le package,\nutiliser :Cette commande induit la création d’un dossier tests qui comprend un fichier testthat.R - à ne pas modifier - et un dossier testthat dans lequel va insérer nos tests. Cet outils s’appuie sur la théorie des tests unitaires.Voici par exemple, le contenu d’un fichier qu’appellera test-univariate.R à mettre dans le dossier testthat :Et un deuxième, appelé test-bivariate.R :Pour exécuter ces tests, peut utiliser dans l’onglet “Build”, le menu\n“”, “Test package” (ou devtools::test() ou Ctrl+Shift+T).L’avantage de ces tests automatiques est qu’ils vont\ns’exécuter à chaque fois qu’effectuera un check du package.Une bonne pratique est d’ajouter un test unitaire à chaque fois qu’un bug est identifier et résolu,\nafin de pouvoir immédiatement identifier et prévenir qu’une erreur identique ne se reproduise dans\nle futur.","code":"\nusethis::use_testthat()\ntest_that(\"correct result for univariate gaussian\", {\n  expect_equal(mvnpdf(x=matrix(1.96), Log=FALSE)$y, dnorm(1.96))\n  expect_equal(mvnpdf(x=matrix(c(1.96, -0.5), ncol = 2), Log=FALSE)$y,\n               dnorm(c(1.96, -0.5)))\n})\ntest_that(\"correct results for bivariate gaussian\", {\n  expect_equal(mvnpdf(x=matrix(rep(1.96,2), nrow=2, ncol=1), Log=FALSE)$y,\n               mvtnorm::dmvnorm(rep(1.96, 2)))\n})"},{"path":"construire-un-package.html","id":"faire-un-check-du-package","chapter":"Chapitre 1 Construire un package ","heading":"1.6 Faire un check du package","text":"Faire un check signifie vérifier que tout est correct dans le package.\nIl est nécessaire de “passer” le check pour pouvoir déposer le package\nsur le CRAN.Pour exécuter celui-ci, utiliser “Check” dans l’onglet “Build” (devtools::check() ou Ctrl+Shift+E).Lors du check, les tests que nous avons mis au point précédemment sont\nexécutées. C’est justement l’avantage d’avoir fait ces tests, nous n’avons\nplus besoin de s’en préoccuper, mais juste de réagir en cas d’erreurs\nrenvoyées.","code":""},{"path":"construire-un-package.html","id":"installer-le-package","chapter":"Chapitre 1 Construire un package ","heading":"1.7 Installer le package","text":"Pour le moment, le package n’existe que dans l’environnement associé au projet\nRstudio qu’créé. Pour pouvoir l’utiliser dans R de manière générale,\nil faut l’installer (comme un package du CRAN par exemple).Pour faire ça, utiliser “Install Restart” dans l’onglet “Build” (devtools::install() ou Ctrl+Shift+B).Et enfin, vous pouvez configurer le comportement de Rstudio pour qu’au moment\nde l’installation, il documente en même temps le package : aller dans\nl’onglet “Build”, le menu “” puis “Configure Build Tools”. Cliquer ensuite\nsur “Configure” puis cocher la case en bas “Install Restart”.","code":""},{"path":"construire-un-package.html","id":"annexe-1.1-ajouter-une-méthode-s3","chapter":"Chapitre 1 Construire un package ","heading":"1.8 Annexe 1.1 : ajouter une méthode S3","text":"Dans la plupart des packages est amenés à implémenter des méthodes S3,\ntrès souvent pour qu’à partir d’un objet résultat res, puisse exécuter\nprint(res), summary(res), plot(res)…Voici un exemple de méthode plot() qu’peut ajouter dans notre package :Attention ! Pour que cette méthode fasse bien ce qu’veut quand \nl’applique au résultat de notre fonction mvnpdf(), il faut déclarer que\nce résultat est de classe mvnpdf.Tester cette fonction, en exécutant l’exemple.N’oubliez pas de réinstaller le package (“Install Restart” ou Ctrl+Shift+B).Consulter le contenu du dossier man et les modifications qui ont été\napportées au fichier NAMESPACE.Voici une proposition de solution : le\nfichier\ncontient le code complet\nde la fonction mvnpdf() et de la méthode plot() associée.","code":"\n#' Plot of the mvnpdf function\n#'\n#' @param x an object of class \\code{mvnpdf} resulting from a call of\n#' \\code{mnvpdf()} function.\n#' @param ... graphical parameters passed to \\code{plot()} function.\n#'\n#' @return Nothing is returned, only a plot is given.\n#' @export\n#'\n#' @examples\n#' pdfvalues <- mvnpdf(x=matrix(seq(-3, 3, by = 0.1), nrow = 1), Log=FALSE)\n#' plot(pdfvalues)\nplot.mvnpdf <- function(x, ...) {\n  plot(x$x, x$y, type = \"l\", ...)\n}"},{"path":"construire-un-package.html","id":"annexe-1.2-soumettre-son-package-au-cran","chapter":"Chapitre 1 Construire un package ","heading":"1.9 Annexe 1.2 : soumettre son package au CRAN","text":"devtools::check() puis devtools::submit_cran()","code":""},{"path":"construire-un-package.html","id":"annexe-1.3-construire-un-site-web-pour-accompagner-son-package","chapter":"Chapitre 1 Construire un package ","heading":"1.10 Annexe 1.3 : construire un site web pour accompagner son package","text":"usethis::use_pkgdown()","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","text":"Nous nous intéressons ici aux solutions proposées par RStudio et GitHub pour\nl’hébergement et le contrôle de version de projets.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"principe-du-contrôle-de-version","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.1 Principe du contrôle de version","text":"Le principe du contrôle de version est d’enregistrer les changements\nsuccessifs apportés à des fichiers (notamment des fichiers R).RStudio propose 2 solutions intégrées pour le contrôle de version :gitgitsvnsvn","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"git","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.1.1 git","text":"git est un logiciel de contrôle de version (c’est-à-dire un outils qui va\nenregistrer l’histoire des changements successifs de votre code et permettre de\npartager ces changements avec d’autres personnes). git est un logiciel en\nligne de commande, et sa prise en main n’est pas nécessairement intuitive.git fonctionne de la façon suivante : sur un serveur dans le ‘cloud’,\nune version à jour du code est disponible. À tout moment il est possible\nd’accéder à cette version du code en ligne. Chaque contributeur peut télécharger\ncette dernière version à jour (dans une action que l’dénomme pull),\navant de l’éditer localement. Une fois ses changements effectués, le\ncontributeur peut alors mettre à jour la version en ligne du code afin que ses\nchangements soient disponibles pour tout le monde (dans une action que l’\ndénomme push)NB : git été pensé pour des fichiers légers (comme par exemple des\nfichiers texte) et est loin d’être optimisé pour des fichiers trop lourds et/où\ncompressés.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"subversion","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.1.2 subversion","text":"subversion est l’autre solution disponible dans RStudio. Elle fonctionne de\nmanière similaire à git, mais avec des fonctionnalités un peu plus réduites\nque nous détaillons pas ici (la différence majeure est que tout les\ncontributeurs travaillent simultanément sur la même version du code).","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"utiliser-git-localement-depuis-rstudio","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.2 Utiliser git localement depuis RStudio","text":"vous de jouer !Commencez par activer git depuis l’onglet “Git/SVN” de “Project Options”\nsitué dans le menu “Tools” et suivre les instructions. Vous pouvez aussi\nutilisé usethis::use_git()Commencez par activer git depuis l’onglet “Git/SVN” de “Project Options”\nsitué dans le menu “Tools” et suivre les instructions. Vous pouvez aussi\nutilisé usethis::use_git()À partir de l’onglet “Git” maintenant apparu à côté de l’onglet “Build”,\nenregistrer l’état actuel de votre package en réalisant votre premier “commit” :À partir de l’onglet “Git” maintenant apparu à côté de l’onglet “Build”,\nenregistrer l’état actuel de votre package en réalisant votre premier “commit” :2a. sélectionner les fichiers à suivre (ne pas sélectionner le fichier .Rproj)2a. sélectionner les fichiers à suivre (ne pas sélectionner le fichier .Rproj)2b. écrire un message informatif (pour vos collaborateurs - ce qui inclut votre futur vous)2b. écrire un message informatif (pour vos collaborateurs - ce qui inclut votre futur vous)2c. cliquer sur “Commit”2c. cliquer sur “Commit”Ajouter une ligne “*.Rproj” au fichier “.gitignore” et effectuez un nouveau commitAjouter une ligne “*.Rproj” au fichier “.gitignore” et effectuez un nouveau commitVisualiser les changements et leur historique à l’aide des outils de visualisation\n“Diff” et “History” accessible depuis l’onglet “Git”Visualiser les changements et leur historique à l’aide des outils de visualisation\n“Diff” et “History” accessible depuis l’onglet “Git”","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"bonnes-pratiques-du-commit","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.2.1 Bonnes pratiques du commit","text":"Idéalement, chaque commit ne devrait régler qu’un seul problème. Il devrait le régler dans\nson intégralité (être complet) et ne contenir des changements relatifs qu’uniquement à\nce problème (être minimal). Il est alors important d’écrire des message de commit\ninformatifs (pensez à vos collaborateur, qui incluent votre futur vous).\nIl faut également être concis, et décrire les raisons des changements plutôt que\nles changements eux-mêmes (visibles dans le Diff). Il est parfois difficile de\nrespecter ces directives à la lettre, et celles-ci ne sont qu’un guide et ne\ndoivent pas vous empêcher d’effectuer des commits réguliers.Par ailleurs, la tentation d’avoir un historique de changements “propre” et bien\nordonné est naturelle, mais se révèle une source de problèmes inutiles. Elle\nentre en contradiction avec l’objectif de traçabilité du contrôle de version.\nLe développement de code étant généralement un processus intellectuel complexe\net non linéaire, il est normal que l’enregistrement des changements reflète ce\ncheminement. En pratique, votre futur-vous sera le premier utilisateur de votre\nhistorique de changements et la priorité est donc de vous faciliter la tache\ndans le futur lors de la résolution de bug où l’extension de fonctionnalités.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"github","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.3 GitHub","text":"GitHub est un site internet proposant une solution\nd’hébergement de code en ligne, et s’appuyant sur git. Il existe de nombreux\nsites web et services (gitlab, bitbucket, …) permettant d’héberger du code et\ns’appuyant sur git. GitHub est très populaire dans la communauté des\ndéveloppeurs R, et est relativement facile à utiliser, même pour un\nutilisateur novice.Les avantages d’utiliser GitHub :une interface graphique simple pour suivre l’historique des changements de votre codeune interface graphique simple pour suivre l’historique des changements de votre codela dernière version de développement de votre code est disponible en ligne et vous pouvez la\nréférencer (peut même référencer un numéro de commit précis pour geler une version spécifique\ndu code)la dernière version de développement de votre code est disponible en ligne et vous pouvez la\nréférencer (peut même référencer un numéro de commit précis pour geler une version spécifique\ndu code)les utilisateurs disposent d’un canal clair et transparent pour signaler les bugs/difficultésles utilisateurs disposent d’un canal clair et transparent pour signaler les bugs/difficultéscela facilite grandement le développement collaboratifcela facilite grandement le développement collaboratif","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"mettre-son-package-r-sur-github","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.3.1 Mettre son package R sur GitHub","text":"vous de jouer !Rendez-vous sur le site https://github.com/ et créez vous un compte\nGitHub (si vous hésitez, une convention courante est d’utiliser prénomnom comme nom d’utilisateur)Rendez-vous sur le site https://github.com/ et créez vous un compte\nGitHub (si vous hésitez, une convention courante est d’utiliser prénomnom comme nom d’utilisateur)Vous pouvez ensuite soit utiliser le client “GitHub desktop” installé sur votre machine en vous connectant au compte GitHub et en suivant les instructions 3 et 4 suivantes, soit utiliser usethis::use_github() et vous laisser guider.Vous pouvez ensuite soit utiliser le client “GitHub desktop” installé sur votre machine en vous connectant au compte GitHub et en suivant les instructions 3 et 4 suivantes, soit utiliser usethis::use_github() et vous laisser guider.Ajouter un nouveau projet local en cliquant sur l’icone “+” en haut à gauche de\nla fenêtre du client, puis en choississant “Add” et en rentrant le chemin du dossier\noù se trouve le code de votre package.Ajouter un nouveau projet local en cliquant sur l’icone “+” en haut à gauche de\nla fenêtre du client, puis en choississant “Add” et en rentrant le chemin du dossier\noù se trouve le code de votre package.Une fois le repertoire créer en local, publiez le sur GitHub en cliquant sur “Publish”\nen haut à droite de la fenêtre du client. Vérifiez sur le site de GitHub que votre\ncode à bien été uploadé avec les 2 commits précédents.Une fois le repertoire créer en local, publiez le sur GitHub en cliquant sur “Publish”\nen haut à droite de la fenêtre du client. Vérifiez sur le site de GitHub que votre\ncode à bien été uploadé avec les 2 commits précédents.Ajouter un fichier “README.Rmd” à votre package afin de disposer d’une belle page\nd’accueil sur GitHub :Ajouter un fichier “README.Rmd” à votre package afin de disposer d’une belle page\nd’accueil sur GitHub :5a. dans RStudio, executez la commande usethis::use_readme_rmd()5a. dans RStudio, executez la commande usethis::use_readme_rmd()5b. à l’aide de l’outilds “Diff” de l’onglet “Git” de RStudio, étudier\nles changements opérer par la commande précédente5b. à l’aide de l’outilds “Diff” de l’onglet “Git” de RStudio, étudier\nles changements opérer par la commande précédente5c. éditez le fichier “README.Rmd” créé, puis créer le fichier README.md\ncorrespondant en executant knitr (cliquer su la pelotte de laine “Knit”\nen haut à gauche dans Rstudio), avant d’effectuer un 3e commit contenant ces\nchangements5c. éditez le fichier “README.Rmd” créé, puis créer le fichier README.md\ncorrespondant en executant knitr (cliquer su la pelotte de laine “Knit”\nen haut à gauche dans Rstudio), avant d’effectuer un 3e commit contenant ces\nchangements5d. à ce stade, si vous visitez la page de votre répertoire sur GitHub,\nvotre 3e commit n’apparait pour l’instant pas. Il faut synchroniser\nle répertoire GitHub en ligne avec votre dossier local. Pour cela, vous\navez 2 solutions : soit utiliser le bouton “Sync” en haut à droit de la\nfenêtre du client GitHub desktop ; soit directement depuis RStudio en cliquant\nsur “Push” depuis l’onglet “Git”. Maintenant, les changements du 3e commit sont\nvisibles en ligne dur GitHub.5d. à ce stade, si vous visitez la page de votre répertoire sur GitHub,\nvotre 3e commit n’apparait pour l’instant pas. Il faut synchroniser\nle répertoire GitHub en ligne avec votre dossier local. Pour cela, vous\navez 2 solutions : soit utiliser le bouton “Sync” en haut à droit de la\nfenêtre du client GitHub desktop ; soit directement depuis RStudio en cliquant\nsur “Push” depuis l’onglet “Git”. Maintenant, les changements du 3e commit sont\nvisibles en ligne dur GitHub.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"collaboration-pour-la-production-du-code","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4 Collaboration pour la production du code","text":"git et GitHub sont particulièrement efficaces lorsque plusieurs personnes collaborent pour\ndévelopper un code. En effet, chacun peut effectuer des pull et push successifs pour\napporter des changements au code, de manière simultanée et en étant sûr de toujours travailler\nsur la dernière version. Nous allons voir différents concepts utiles dans le cas d’un tel travail\ncollaboratif.vous de jouer !En formant des groupes de 2, vous allez chacun ajouter votre binome comme “collaborator”\nà votre repertoire GitHub à partir de l’onglet “Settings” (sur GitHub).En formant des groupes de 2, vous allez chacun ajouter votre binome comme “collaborator”\nà votre repertoire GitHub à partir de l’onglet “Settings” (sur GitHub).Quelques instants plus tard le collaborateur ainsi ajouté reçoit un email l’invitant à\naccepter l’ajout. Cliquer sur le lien et accepter.Quelques instants plus tard le collaborateur ainsi ajouté reçoit un email l’invitant à\naccepter l’ajout. Cliquer sur le lien et accepter.Dans le client “GitHub desktop”, ajouter le répertoire de votre binôme en cliquant sur\nl’icone “+” en haut à gauche et en selectionnant “Clone”, ce qui fait apparaitre la liste\ndes repertoires associés à votre compte GitHub non liés à un dossier local.\nSélectionner le projet de votre binome.Dans le client “GitHub desktop”, ajouter le répertoire de votre binôme en cliquant sur\nl’icone “+” en haut à gauche et en selectionnant “Clone”, ce qui fait apparaitre la liste\ndes repertoires associés à votre compte GitHub non liés à un dossier local.\nSélectionner le projet de votre binome.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"branches","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.1 Branches","text":"Une des fonctionnalités assez utile de git est les branches. Cela permet d’opérer des changements\nimportants dans le code sans perturber le fonctionnement actuel. C’est notamment utile pour explorer\nune piste de développement dont ne sait pas si elle sera concluante au final.D’ailleurs, vous utilisez déjà les branches depuis le depuis de cette partie. En effet, la branche\npar défaut est appelé “master”.Grâce à ce système de branches, obtient un arbre des différents commits au cours du temps (où\nles nœuds correspondent à la séparations des branches).","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"merge","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.2 Merge","text":"Un pull se décompose en 2 actions de la part de git :tout d’abord un fetch, qui correspond au téléchargement du code en lignetout d’abord un fetch, qui correspond au téléchargement du code en lignesuivi d’un merge qui fusionne la version locale avec les changements.suivi d’un merge qui fusionne la version locale avec les changements.Après avoir conduit un développement expérimental dans une branche, peut vouloir merger ces\nchangements dans la branche “master” par exemple, après que l’expérience se soit révélée\nconcluante.Si un les changements concernent des parties distinctes du code, alors le merge peut\ns’effectuer sans problème. En revanche si les 2 versions à merger comportent des changements\ndepuis leur dernier commit commun qui concerne les mêmes lignes de codes, alors va rencontrer\nun (ou des ) conflit(s), qu’il va falloir résoudre.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"les-conflits","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.3 Les conflits","text":"Prenons l’exemple suivant : le développeur \\(D_1\\) et le développeur \\(D_2\\) tous les 2 pullé la\nversion v0.1 du code à l’instant \\(t\\) sur leur machine respective. Ils travaillent chacun\nindépendamment pour apporter des changements au code. Au moment de pusher ses changements,\nle développeur \\(D_2\\) reçoit un message d’erreur :“Sync Error.\nPlease resolve conflicted files, commit, try syncing .”Chaque fichier étant source de conflit alors été automatiquement édité comme suit :Pour résoudre le conflit, il faut alors éditer chaque fichier un à un en choisissant s’il faut\nconserver la version locale ou bien celle en ligne, avant de pouvoir commiter à nouveau et enfin\nde pusher vos changements avec succès.vous de jouer !Modifiez le fichier README.Rmd de votre binome, puis commitez votre changement et pushez\nle.Modifiez le fichier README.Rmd de votre binome, puis commitez votre changement et pushez\nle.une fois que votre binôme modifié votre README.Rmd, modifiez à votre tour le fichier\nà la même ligne, SANS puller les changements de votre binôme au préalable ! Commitez et\nessayez de pusher ces changements.une fois que votre binôme modifié votre README.Rmd, modifiez à votre tour le fichier\nà la même ligne, SANS puller les changements de votre binôme au préalable ! Commitez et\nessayez de pusher ces changements.Résolvez le conflit.Résolvez le conflit.NB: Dans la vraie vie, cherche à éviter cette situation et donc va toujours puller avant de pusher. Ici, nous faisons volontairement le contraire pour donner un exemple et démystifier les conflits.","code":"<<<<<<< HEAD\ncode dans votre version local\n=======\ncode en ligne\n>>>>>>> remote"},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"fork","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.4 Fork","text":"L’action fork permet de créer une copie qui vous appartient à partir d’un code disponible. Ainsi\nle code original ne sera pas impacté par vos changements. Cela revient à créer une branche, et la\nséparer de l’arbre pour pouvoir en assumer la propriété. aurait aussi pu appeler cette action une “bouture”…Cette action est principalement utile dans le cadre des pull requests.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"pull-request","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.5 Pull request","text":"Il s’agit du moyen le plus facile de proposer des changements dans un code dont vous n’êtes pas\ncollaborateur. GitHub propose une interface graphique facilitant leur traitement.vous de jouer !Modifiez le README.Rmd de votre voisin qui n’est pas votre binôme après avoir forké son\npackage.Modifiez le README.Rmd de votre voisin qui n’est pas votre binôme après avoir forké son\npackage.Proposez votre changement sous la forme d’une pull request depuis l’onglet “Pull requests” sur la page GitHub du répertoire de votre voisin.Proposez votre changement sous la forme d’une pull request depuis l’onglet “Pull requests” sur la page GitHub du répertoire de votre voisin.Acceptez la pull request de votre voisin sur la page GitHub de votre répertoire, puis faire le merge.Acceptez la pull request de votre voisin sur la page GitHub de votre répertoire, puis faire le merge.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"issues","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.4.6 Issues","text":"Pour n’importe quel répertoire GitHub, vous pouvez poster un commentaire sous forme d’issue\nafin d’alerter les développeurs sur un éventuel bug, ou une question sur l’utilisation du package,\nou encore demander une fonctionnalité supplémentaire…L’idéal est de proposer vous-même une pull request qui résout votre issue lorsque vous\nle pouvez (.e. en avez les capacités et le temps).vous de jouer !Utilisez usethis::use_github_links() afin d’ajouter les 2 lignes suivantes au fichier DESCRIPTION de votre packageURL: http://github.com/*prenom.nom*/mypkgBugReports: http://github.com/*prenom.nom*/mypkg/issuesUtilisez usethis::use_github_links() afin d’ajouter les 2 lignes suivantes au fichier DESCRIPTION de votre packageURL: http://github.com/*prenom.nom*/mypkgBugReports: http://github.com/*prenom.nom*/mypkg/issuesVisualisez les nouveau changements, puis commitez les.Visualisez les nouveau changements, puis commitez les.Créez une issue sur le projet de votre binomeCréez une issue sur le projet de votre binome","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"intégration-continue","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.5 Intégration continue","text":"À chaque changement, à chaque commit donc, il y la possibilité d’introduire 1 (ou plusieurs) bugs qui vont empêcher le package de passer le CRAN check. Si l’accumule trop de ces bugs, au moment de soumettre la nouvelle version, il peut y avoir beaucoup de corrections à apporter. C’est d’autant plus frustrant si le package passait le CRAN check auparavant…Les services d’intégration continue permettent de checker votre package automatiquement après chaque commit ! En cas d’échec, vous recevez un mail qui vous en informe. Un certain nombre de ces services proposent une offre limitée gratuite pour les projets open-source.Une autre raison d’utiliser l’intégration continue est qu’elle permet de tester votre package sur des infrastructures différentes de la votre (e.g. Windows, Ubuntu, Mac OS) et pour différentes versions de  (current, devel…)","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"github-actions","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.5.1 GitHub Actions","text":"Les Github actions permettent de lancer des actions automatiquement à chaque fois que vous pushez sur GitHub La commande usethis::use_github_action_check_standard() permet d’initialiser les Github Actions, et d’ajouter l’action R CMD CHECK du package.vous de jouer !Executez la commande usethis::use_github_action_check_standard() et commitez les changements et regardez ce qu’il se passe sur la page GitHubExecutez la commande usethis::use_github_action_check_standard() et commitez les changements et regardez ce qu’il se passe sur la page GitHubAjouter un badge à votre README.md grâce au code obtenu dans la console R et commitez ces changementsAjouter un badge à votre README.md grâce au code obtenu dans la console R et commitez ces changementsN’hésitez pas à consulter la page suivantes qui renseigne sur les différentes GitHub Actions disponibles pour les pacakges  : https://github.com/r-lib/actions/blob/v1/examples/README.md","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"r-hub","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.5.2 R-hub","text":"Le R consortium met à disposition le R-hub builder,\n- et pour ambition de bientôt proposer un service d’intégration continue spécialement dédié aux packages R.","code":""},{"path":"contrôle-de-version-avec-git-et-github-historique-de-changement-développement-collaboratif-et-intégration-continue.html","id":"annexe-2.1-couverture-du-code","chapter":"Chapitre 2 Contrôle de version avec git et GitHub : historique de changement, développement collaboratif et intégration continue","heading":"2.6 Annexe 2.1 : couverture du code","text":"Le package covr propose une solution pour mesurer la couverture des tests unitaires associés à un\npackage. La couverture de test détermine la proportion du code source qui est effectivement utilisée\nlors de l’exécution des tests unitaires. La mesure de la couverture du code renforce la fiabilité\nd’un code et donne confiance à ses utilisateurs potentiels.vous de jouer !Executez la commande usethis::use_coverage(), ajouter un joli badge à votre README.md grâce au code obtenu dans la console RCommitez ces changements.Pour plus d’information n’hésitez pas à consulter la vignette de covr.","code":""},{"path":"mesurer-et-comparer-des-temps-dexécution.html","id":"mesurer-et-comparer-des-temps-dexécution","chapter":"Chapitre 3 Mesurer et comparer des temps d’exécution","heading":"Chapitre 3 Mesurer et comparer des temps d’exécution","text":"La première étape avant d’optimiser un code est de pouvoir mesurer son temps d’exécution,\nafin de pouvoir comparer les temps d’exécution entre différente implémentations.","code":""},{"path":"mesurer-et-comparer-des-temps-dexécution.html","id":"mesurer-des-temps-dexécution-avec-system.time","chapter":"Chapitre 3 Mesurer et comparer des temps d’exécution","heading":"3.1 Mesurer des temps d’exécution avec system.time()","text":"Pour mesure le temps d’exécution d’une commande R, peut utiliser la\nfonction system.time() comme ceci :Le problème qui apparaît sur cet exemple est que l’exécution est tellement\nrapide que system.time() affiche 0 (ou une valeur très proche).\nDe plus, voit qu’il y une certaine variabilité quand relance plusieurs\nfois la commande.Ainsi si souhaite comparer notre code avec la fonction mvtnorm::dmvnorm(),\nne peut pas utiliser system.time() :pourrait se dire qu’il faut augmenter la complexité de notre calcul, mais\nil y mieux : utiliser le package microbenchmark !","code":"\nsystem.time(mvnpdf(x=matrix(rep(1.96, 2), nrow=2, ncol=1), Log=FALSE))##    user  system elapsed \n##   0.001   0.001   0.002\nsystem.time(mvtnorm::dmvnorm(rep(1.96, 2)))##    user  system elapsed \n##   0.003   0.001   0.005"},{"path":"mesurer-et-comparer-des-temps-dexécution.html","id":"comparer-des-temps-dexécution-avec-microbenchmark","chapter":"Chapitre 3 Mesurer et comparer des temps d’exécution","heading":"3.2 Comparer des temps d’exécution avec microbenchmark()","text":"Comme son nom l’indique, ce package permet justement de comparer des temps\nd’exécution même quand ceux-ci sont très faibles. De plus, la fonction\nmicrobenchmark() va répéter un certain nombre de fois l’exécution des\ncommandes et donc va stabiliser le résultat.Les deux fonctions mvnpdf() et dmnvorm() étant capables de prendre en\nentrée une matrice, peut également comparer leurs comportements dans ce\ncas :Il s’est passé un quelque chose… Et va diagnostiquer ce problème dans la suite.","code":"\nlibrary(microbenchmark)\nmb <- microbenchmark(mvtnorm::dmvnorm(rep(1.96, 2)),\n                     mvnpdf(x=matrix(rep(1.96,2)), Log=FALSE),\n                     times=1000L)## Warning in microbenchmark(mvtnorm::dmvnorm(rep(1.96, 2)), mvnpdf(x =\n## matrix(rep(1.96, : less accurate nanosecond times to avoid potential integer\n## overflows\nmb## Unit: microseconds\n##                                           expr    min     lq     mean median\n##                 mvtnorm::dmvnorm(rep(1.96, 2)) 19.926 20.828 23.61055 21.361\n##  mvnpdf(x = matrix(rep(1.96, 2)), Log = FALSE) 18.327 19.270 20.28520 19.639\n##      uq      max neval cld\n##  22.181 1563.535  1000  a \n##  20.459   89.052  1000   b## Warning: The `guide` argument in `scale_*()` cannot be `FALSE`. This was deprecated in ggplot2 3.3.4.\n## ℹ Please use \"none\" instead.\n## This warning is displayed once every 8 hours.\n## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\nn <- 100\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                       expr     min      lq\n##         mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))  23.411  24.477\n##  mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 268.468 271.707\n##       mean   median       uq     max neval cld\n##   28.21825  25.4200  26.8960  97.252   100  a \n##  281.37398 273.7365 282.1005 364.900   100   b"},{"path":"profiler-son-code.html","id":"profiler-son-code","chapter":"Chapitre 4 Profiler son code","heading":"Chapitre 4 Profiler son code","text":"parle de profiling en anglais. Il s’agit de déterminer ce qui prend\ndu temps dans un code. Le étant une fois trouvé le bloc de code qui prend\nle plus de temps dans l’exécution d’optimiser uniquement cette brique.Pour obtenir un profiling du code ci-dessous, sélectionner les lignes de code\nd’intérêt et aller dans le menu “Profile” puis “Profile Selected Lines” (ou\nCtrl+Alt+Shift P).OK, get ! Concaténer un vecteur au fur et à mesure dans une boucle\nn’est vraiment pas une bonne idée.","code":"\nn <- 10e4\npdfval <- mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)"},{"path":"profiler-son-code.html","id":"comparaison-avec-une-version-plus-habile-de-mnvpdf","chapter":"Chapitre 4 Profiler son code","heading":"4.1 Comparaison avec une version plus habile de mnvpdf()","text":"Considérons une nouvelle version de mvnpdf(), appelée mvnpdfsmart().\nTélécharger le\nfichier puis\nl’inclure dans le package.Profiler la commande suivante :effectivement résolu le problème et apprend maintenant de manière plus\nfine ce qui prend du temps dans notre fonction.Pour confirmer que mvnpdfsmart() est effectivement bien plus rapide que\nmvnpdf() peut re-faire une comparaison avec microbenchmark() :Et peut également voir si devient compétitif avec dmvnorm() :Il y encore du travail…","code":"\nn <- 10e4\npdfval <- mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)\nn <- 1000\nmb <- microbenchmark(mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: milliseconds\n##                                                            expr      min\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3.083077\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2.310637\n##        lq     mean   median       uq      max neval cld\n##  3.224035 3.729692 3.355645 3.529587 8.155720   100  a \n##  2.338824 2.374991 2.357992 2.389172 2.578982   100   b\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   43.419\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3122.109\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2305.963\n##         lq       mean   median        uq      max neval cld\n##    49.7125   62.60003   58.671   71.6065   97.457   100 a  \n##  3342.6480 3739.18565 3415.854 3466.1605 7962.364   100  b \n##  2328.6360 2358.91573 2343.376 2368.6725 2492.185   100   c"},{"path":"profiler-son-code.html","id":"comparaison-avec-une-version-optimisée-dans-r","chapter":"Chapitre 4 Profiler son code","heading":"4.2 Comparaison avec une version optimisée dans R","text":"Boris est arrivée après plusieurs recherches et tests à une\nversion optimisée\navec les outils de R.Inclure la fonction mvnpdfoptim() dans le package, puis profiler cette\nfonction :Et un petit microbenchmark() :Pour finir peut profiler la fonction dmvnorm() :","code":"\nn <- 10e4\npdfval <- mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE)\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   43.419\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3099.723\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2304.159\n##  mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 1744.222\n##         lq       mean   median       uq       max neval  cld\n##    53.4845   64.94646   63.017   72.939   107.707   100 a   \n##  3274.5880 3689.51415 3387.379 3462.101 11497.589   100  b  \n##  2345.3230 2502.91593 2385.298 2418.672  6630.110   100   c \n##  1773.2090 1847.76545 1802.606 1849.387  4712.007   100    d\nn <- 10e5\npdfval <- mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))"},{"path":"rcpp-ou-comment-intégrer-facilement-du-code-cdans-un-package-r.html","id":"rcpp-ou-comment-intégrer-facilement-du-code-cdans-un-package-r","chapter":"Chapitre 5 Rcpp ou comment intégrer facilement du code C++dans un package R","heading":"Chapitre 5 Rcpp ou comment intégrer facilement du code C++dans un package R","text":"Rcpp (R-C-Plus-Plus) est un package qui facilite l’interface entre C++ et R. R est un langage\ninterprété, ce qui facilite un certain nombre de choses (notamment nous donne accès à la console\ndans laquelle peut évaluer du code à la volée). Néanmoins, cette facilité d’utilisation se\ncompense entre autre par des temps de calcul supérieurs à ceux de langages de plus bas niveau,\ntels que C, Fortran et C++ (mais qui nécessitent eux une compilation).dirigera le lecteur curieux vers le livre en ligne\nRcpp everyone de Masaki E. Tsuda, qui\nconstitue une ressource très complète pour comprendre l’utilisation de Rcpp en plus de\nl’introduction que l’peut trouver dans le livre Advanced R d’Hadley\nWickham.","code":""},{"path":"rcpp-ou-comment-intégrer-facilement-du-code-cdans-un-package-r.html","id":"première-fonction-en-rcpp","chapter":"Chapitre 5 Rcpp ou comment intégrer facilement du code C++dans un package R","heading":"5.1 Première fonction en Rcpp","text":"vous de jouer !Afin de rendre votre package prêt pour l’utilisation avec Rcpp, commencez par executer la commande\nsuivante :Constatez les changements apportésConstatez les changements apportésil faut également ajouter les 2 commentaires roxygen suivants dans la page d’aide du\npackage dans son ensemble :il faut également ajouter les 2 commentaires roxygen suivants dans la page d’aide du\npackage dans son ensemble :Nous allons maintenant créer une première fonction en Rcpp permettant d’inverser une matrice.\nPour cela, nous allons nous appuyer sur la library C++ Armadillo.\nIl s’agit d’une library d’algèbre linéaire moderne et simple, hautement optimisée, et interfacée\navec R via le package RcppArmadillo.C++ n’est pas un langage très différent de R. Les principales différences qui nous concernent :C++est très efficaces pour le boucles (y compris les boucles emboîtées). Attention :\nil y souvent un sens qui est plus rapide que l’autre (ceci est dû à la manière dont C++ attribue\net parcours la mémoire).C++est très efficaces pour le boucles (y compris les boucles emboîtées). Attention :\nil y souvent un sens qui est plus rapide que l’autre (ceci est dû à la manière dont C++ attribue\net parcours la mémoire).Chaque commande doit se terminer par un point virgule ‘;’Chaque commande doit se terminer par un point virgule ‘;’C++est un langage typé : il faut déclarer le type de chaque variable avant de pouvoir\nl’utiliser.C++est un langage typé : il faut déclarer le type de chaque variable avant de pouvoir\nl’utiliser.vous de jouer !Créez un nouveau fichier C++ depuis RStudio (via le menu File > New File > C++ File), et enregistrez le dans le dossier src. Prenez le temps de le lire et essayez de comprendre chaque ligne.Créez un nouveau fichier C++ depuis RStudio (via le menu File > New File > C++ File), et enregistrez le dans le dossier src. Prenez le temps de le lire et essayez de comprendre chaque ligne.Compilez et chargez votre package (via le bouton “Install Restart”) et essayez d’utiliser la fonction timesTwo() depuis la console.Compilez et chargez votre package (via le bouton “Install Restart”) et essayez d’utiliser la fonction timesTwo() depuis la console.Installez le package RcppArmadillo, et n’oubliez pas de faire les ajouts nécessaires dans DESCRIPTION (cf. usethis::use_rcpp_armadillo())Installez le package RcppArmadillo, et n’oubliez pas de faire les ajouts nécessaires dans DESCRIPTION (cf. usethis::use_rcpp_armadillo())À l’aide de l’[introduction à Rcpp]](http://adv-r..co.nz/Rcpp.html#rcpp-intro) de Hadley Wickham dans son livre Advanced R, ainsi que de la documentation du package RcppArmadillo de celle de la library C++ Armadillo, tentez d’écrire une courte fonction invC en C++ calculant l’inverse d’une matrice.À l’aide de l’[introduction à Rcpp]](http://adv-r..co.nz/Rcpp.html#rcpp-intro) de Hadley Wickham dans son livre Advanced R, ainsi que de la documentation du package RcppArmadillo de celle de la library C++ Armadillo, tentez d’écrire une courte fonction invC en C++ calculant l’inverse d’une matrice.Lorsque vous avez réussi à compiler votre fonction invC et qu’elle est accessible depuis  créer une fonction mvnpdf_invC() à partir de l’implémentation de mvnpdfsmart en remplaçant uniquement les calculs d’inverse matriciel par un appel à invC.Lorsque vous avez réussi à compiler votre fonction invC et qu’elle est accessible depuis  créer une fonction mvnpdf_invC() à partir de l’implémentation de mvnpdfsmart en remplaçant uniquement les calculs d’inverse matriciel par un appel à invC.Evaluer le gain en performance de cette nouvelle implémentation mvnpdf_invC.Evaluer le gain en performance de cette nouvelle implémentation mvnpdf_invC.","code":"\ndevtools::use_rcpp()\n#' @useDynLib mypkgr\n#' @importFrom Rcpp sourceCpp, .registration = TRUE\nNULL\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdf_invC(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                            expr      min\n##              mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))   44.362\n##       mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 3128.013\n##  mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2319.083\n##  mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 1736.760\n##  mvnpdf_invC(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE) 2308.915\n##         lq       mean    median        uq       max neval  cld\n##    57.0105   71.60773   71.7295   82.5945   121.729   100 a   \n##  3269.9960 3542.48897 3375.3250 3470.0145  7743.998   100  b  \n##  2356.2495 2509.33161 2379.7220 2423.2435 10112.486   100   c \n##  1789.4860 1931.05695 1825.0740 1853.6715  5658.410   100    d\n##  2351.1245 2517.90266 2375.3350 2410.1645  6439.214   100   c\nprofvis::profvis(mvnpdfoptim(x=matrix(1.96, \n    nrow = 2, ncol = 1000), Log=FALSE))\nprofvis::profvis(mvnpdfoptim(x=matrix(1.96, \n    nrow = 100, ncol = 1000), Log=FALSE))"},{"path":"rcpp-ou-comment-intégrer-facilement-du-code-cdans-un-package-r.html","id":"optimisation-grâce-à-c","chapter":"Chapitre 5 Rcpp ou comment intégrer facilement du code C++dans un package R","heading":"5.2 Optimisation grâce à C++","text":"En règle générale, ne gagne pas beaucoup en temps de calcul en remplaçant une fonction R\noptimisée par une fonction en C++. En effet, la plupart des fonctions de base de R s’appuie en\nréalité déjà sur des routines C ou Fortran bien optimisée. Le gain se limite alors simplement\nà la suppression des vérifications des arguments et de la gestion des différents types.vous de jouer !À partir de mvnpdfsmart, proposez une implémentation completement en C++ du calcul\nde densité de la loi Normale multivariée mvnpdfC().À partir de mvnpdfsmart, proposez une implémentation completement en C++ du calcul\nde densité de la loi Normale multivariée mvnpdfC().Evaluer le gain en performance de cette nouvelle implémentation mvnpdfCEvaluer le gain en performance de cette nouvelle implémentation mvnpdfCVous pouvez télécharger notre proposition de mvnpdfC.cpp ici.À noter que vous pouvez utiliser des fonctions Rcpp en dehors de l’architecture\nd’un package grâce à la fonction Rcpp::sourceCpp(). Mais comme nous avons\nqu’il est préférable de gérer tous ces code sous la forme de package, il est\npeu probable que vous en ayez besoin !","code":"\nn <- 1000\nmb <- microbenchmark(mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n                     mvnpdf(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfsmart(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdf_invC(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n                     mvnpdfC(x=matrix(1.96, nrow = 2, ncol = n), mean = rep(0, 2), varcovM = diag(2), Log=FALSE),\n                     times=100L)\nmb## Unit: microseconds\n##                                                                                                  expr\n##                                                    mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))\n##                                             mvnpdf(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                        mvnpdfsmart(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                        mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                                        mvnpdf_invC(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##  mvnpdfC(x = matrix(1.96, nrow = 2, ncol = n), mean = rep(0, 2),      varcovM = diag(2), Log = FALSE)\n##       min        lq       mean    median        uq      max neval  cld\n##    43.829   53.4845   62.76772   60.9670   71.1555  100.901   100 a   \n##  3108.456 3257.2655 3560.86681 3430.4290 3485.0410 7903.242   100  b  \n##  2319.452 2349.0335 2414.52567 2369.4925 2393.5800 6000.391   100   c \n##  1736.924 1774.0700 1878.94841 1792.0485 1819.3135 5915.603   100    d\n##  2310.801 2338.6605 2541.02748 2354.9375 2383.0020 6964.465   100   c \n##    35.260   38.6835   48.45175   41.0205   43.4805  686.750   100 a"},{"path":"rcpp-ou-comment-intégrer-facilement-du-code-cdans-un-package-r.html","id":"annexe-5.1-loptimisation-prématurée-nest-pas-une-bonne-idée","chapter":"Chapitre 5 Rcpp ou comment intégrer facilement du code C++dans un package R","heading":"5.3 Annexe 5.1 : l’optimisation prématurée n’est pas une bonne idée","text":"Chambers, Software Data Analysis: Programming R, Springer, 2008 :Including additional C code serious step, added dangers\noften substantial amount programming debugging required.\ngood reason.","code":""},{"path":"parallélisation-du-code-r.html","id":"parallélisation-du-code-r","chapter":"Chapitre 6 Parallélisation du code R","heading":"Chapitre 6 Parallélisation du code R","text":"","code":""},{"path":"parallélisation-du-code-r.html","id":"introduction-à-lexecution-parallèle-sous-r","chapter":"Chapitre 6 Parallélisation du code R","heading":"6.1 Introduction à l’execution parallèle sous R","text":"En dehors de l’optimisation du code et des algorithmes, une autre façon\nd’obtenir un code performant est de tirer profit des architectures parallèles\ndes ordinateurs modernes. Il s’agit alors de paralléliser son code afin de\nfaire des opérations simultanées sur des parties distinctes d’un même problème,\nen utilisant différent cœurs de calcul. ne réduit pas le temps de calcul\ntotal nécessaire, mais l’ensemble des opérations s’exécute plus rapidement.Il existe un nombre non négligeable d’algorithmes qui sont d’un “parallélisme\nembarrassant”, c’est-à-dire dont les calculs peuvent se décomposer en plusieurs\nsous-calculs indépendants. En statistique, il est ainsi souvent facile et direct\nde paralléliser selon les différentes observations ou selon les différentes\ndimensions. Typiquement, il s’agit d’opérations que l’peut écrire sous la\nforme de boucle dont les opérations sont indépendantes d’une itération de la\nboucle à l’autre.Les opérations nécessaires pour l’établissement d’un code parallèle sont les suivantes :Démarrer \\(m\\) processus “travailleurs” (.e. cœurs de calcul) et les initialiserDémarrer \\(m\\) processus “travailleurs” (.e. cœurs de calcul) et les initialiserEnvoyer les fonctions et données nécessaires pour chaque tache aux travailleursEnvoyer les fonctions et données nécessaires pour chaque tache aux travailleursSéparer les taches en \\(m\\) opérations d’envergure similaire et les envoyer aux travailleursSéparer les taches en \\(m\\) opérations d’envergure similaire et les envoyer aux travailleursAttendre que tous les travailleurs aient terminer leurs calculs et obtenir leurs résultatsAttendre que tous les travailleurs aient terminer leurs calculs et obtenir leurs résultatsRassembler les résultats des différents travailleursRassembler les résultats des différents travailleursArrêter les processus travailleursArrêter les processus travailleursSelon les plateformes, plusieurs protocoles de communications sont disponibles\nentre les cœurs. Sous les systèmes UNIX, le protocole Fork est le plus\nutilisé, mais il n’est pas disponible sous Windows où utilise\npréférentiellement le protocole PSOCK. Enfin, pour les architecture de calcul\ndistribuée où les cœurs ne se trouvent pas nécessairement sur le même processeur\nphysique, utilise généralement le protocole MPI. L’avantage des packages\nfuture et future.apply est que le même code pourra être exécuté quelque soit\nla configuration matérielle.Il existe un nombre important de packages et d’initiatives permettant de faire\ndu calcul en R. Depuis R 2.14.0, le package\nparallel\nest inclus directement dans R et permet de démarrer et d’arrêter un “cluster”\nde plusieurs processus travailleur (étape 1 et 6). En plus du package\nparallel, va donc utiliser le package future qui permet de gérer les\nprocessus travailleurs et la communication et l’articulation avec le package\nfuture.applyqui permet lui de gérer le dialogue avec les travailleurs (envois,\nréception et rassemblement des résultats - étapes 2, 3, 4 et 5).","code":""},{"path":"parallélisation-du-code-r.html","id":"première-fonction-parallèle-en-r","chapter":"Chapitre 6 Parallélisation du code R","heading":"6.2 Première fonction parallèle en R","text":"À vous de jouer !Commencez par écrire une fonction simple qui calcule le logarithme de \\(n\\)\nnombres:Déterminez combien de coeurs sont disponibles sur votre marchine grâce à\nla fonction future::availableCores().Déterminez combien de coeurs sont disponibles sur votre marchine grâce à\nla fonction future::availableCores().À l’aide de la fonction future::plan(multisession(workers = XX)),\ndéclarez un “plan” de calculs parallèles sur votre ordinateur (en prenant garde\nà laisser un coeur disponible pour traiter les autres processus).À l’aide de la fonction future::plan(multisession(workers = XX)),\ndéclarez un “plan” de calculs parallèles sur votre ordinateur (en prenant garde\nà laisser un coeur disponible pour traiter les autres processus).À l’aide d’une fonction de type apply future.apply::future_*apply(),\ncalculez le log des \\(n\\) nombres en parallèle et concaténez les résultats dans un\nvecteur.À l’aide d’une fonction de type apply future.apply::future_*apply(),\ncalculez le log des \\(n\\) nombres en parallèle et concaténez les résultats dans un\nvecteur.Comparez le temps d’éxecution avec celui d’une fonction séquentielle\nsur les 100 premiers entiers, grâce à la commande :microbenchmark(log_par(1:100), log_seq(1:100), times=10)Comparez le temps d’éxecution avec celui d’une fonction séquentielle\nsur les 100 premiers entiers, grâce à la commande :microbenchmark(log_par(1:100), log_seq(1:100), times=10)La version parallèle tourne beaucoup plus lentement… Car en fait, si les\ntâches individuelles sont trop rapides, R va passer plus de temps à\ncommuniquer avec les cœurs, qu’à faire les calculs effectifs.Il faut qu’une itération de la boucle soit relativement longue pour que le\ncalcul parallèle apporte un gain en temps de calcul !En augmentant \\(n\\), observe une réduction de la différence entre les 2\nimplémentations (le temps de calcul en parallèle augmente très lentement comparé\nà l’augmentation de celui de la fonction séquentielle).NB : les itérateurs d’itertools sont très performants mais ne peuvent\nservir que lorsque le code à l’intérieur de future_*apply() est vectorisé (il\nest toujours possible de vectoriser le code à l’intérieur, par exemple avec une\nfonction de type apply). Ils minimisent le nombre de communication entre les\ncoeurs.","code":"\nlibrary(microbenchmark)\nlibrary(future.apply)\n\nlog_seq <- function(x){\n  # try this yourself (spoiler alert: it is quite long...):\n  # res <- numeric(length(x))\n  # for(i in 1:length(x)){\n  #   res[i] <- log(x[i])\n  # }\n  # return(res)\n  return(log(x))\n}\n\nlog_par <- function(x){\n  res <- future_sapply(1:length(x), FUN = function(i) {\n    log(x[i])\n  })\n  return(res)\n}\n\nplan(multisession(workers = 3))\nmb <- microbenchmark(log_par(1:100), log_seq(1:100), times = 50)"},{"path":"parallélisation-du-code-r.html","id":"parallélisation-efficace","chapter":"Chapitre 6 Parallélisation du code R","heading":"6.3 Parallélisation efficace","text":"va maintenant se pencher sur un autre cas d’utilisation. Imaginons que l’\nait un grand tableau de données de taille comportant 10 observations pour 100\n000 variables (e.g. des mesures de génomique), et que l’veuille calculer la\nmédiane pour chacune de ces variables.Pour un utilisateur averti de R, une telle opération se programme facilement\nà l’aide de la fonction apply :En réalité, une boucle n’est pas plus lente à condition d’être bien\nprogrammée :À vous de jouer !\nEssayez d’améliorer encore ce temps de calcul en parallélisant :Parallélisez le calcul de la médiane de chacune des 100 000 variables.\nObserve-t-un gain en temps de calcul ?Parallélisez le calcul de la médiane de chacune des 100 000 variables.\nObserve-t-un gain en temps de calcul ?Proposez une implémentation alternative grâce à la fonction\nitertools::isplitIndices() qui permet de séparer vos données (les \\(n\\) nombres)\nen autant de groupes que vous avez de coeurs. Comparez à nouveau les temps de\ncalcul.Proposez une implémentation alternative grâce à la fonction\nitertools::isplitIndices() qui permet de séparer vos données (les \\(n\\) nombres)\nen autant de groupes que vous avez de coeurs. Comparez à nouveau les temps de\ncalcul.","code":"\nx <- matrix(rnorm(1e6), nrow = 10)\ndim(x)## [1]     10 100000\ncolmedian_apply <- function(x){\n  return(apply(x, 2, median))\n}\nsystem.time(colmedian_apply(x))##    user  system elapsed \n##   1.527   0.004   1.531\ncolmedian_for <- function(x){\n  ans <- rep(0, ncol(x)) \n  for (i in 1:ncol(x)) {\n    ans[i] <- median(x[, i]) \n  }\n  return(ans)\n}\nsystem.time(colmedian_for(x))##    user  system elapsed \n##   1.476   0.003   1.478\ncolmedian_par <- function(x){\n  res <- future_sapply(1:ncol(x), FUN = function(i) {\n          median(x[, i])\n    })\n  return(res)\n}\nplan(multisession(workers = 3))\nsystem.time(colmedian_par(x))##    user  system elapsed \n##   0.097   0.016   0.712\ncolmedian_parIter <- function(x, ncores = 1){\n  iter <- itertools::isplitIndices(n = ncol(x), chunks = ncores)\n  res <- future_sapply(iter, FUN = function(i) {\n          apply(x[, i], 2, median)\n    })\n  return(unlist(res))\n}\nsystem.time(colmedian_parIter(x, ncores = 3))##    user  system elapsed \n##   0.048   0.014   0.540\nmb <- microbenchmark(colmedian_apply(x), \n                     colmedian_for(x),\n                     colmedian_par(x),\n                     colmedian_parIter(x, ncores = 3), times = 10)\nmb## Unit: milliseconds\n##                              expr       min        lq      mean    median\n##                colmedian_apply(x) 1146.2693 1173.4495 1194.9441 1189.6657\n##                  colmedian_for(x) 1110.8893 1128.4085 1161.2218 1157.9027\n##                  colmedian_par(x)  552.1889  557.7954  565.7271  563.7149\n##  colmedian_parIter(x, ncores = 3)  492.4648  494.2154  501.4810  500.1446\n##         uq       max neval cld\n##  1207.9525 1263.9378    10 a  \n##  1189.2213 1239.7713    10 a  \n##   576.9173  578.1943    10  b \n##   502.7662  518.6836    10   c"},{"path":"parallélisation-du-code-r.html","id":"les-itérateurs","chapter":"Chapitre 6 Parallélisation du code R","heading":"6.3.1 Les itérateurs","text":"Le package itertools permet de séparer facilement des données ou des\ntaches (étape 3) tout en minimisant les communications avec les différents\ntravailleurs. Il s’appuie sur une implémentation des itérateurs en R.\nSon utilisation nécessite néanmoins de vectoriser le code à l’intérieur de\nfuture_*apply(). Expérimentez avec le petit code ci-dessous :","code":"\nmyiter <- itertools::isplitIndices(n = 30, chunks = 3)\n\n# Une première fois\niterators::nextElem(myiter)##  [1]  1  2  3  4  5  6  7  8  9 10\n# Une deuxième fois... Oh ?!\niterators::nextElem(myiter)##  [1] 11 12 13 14 15 16 17 18 19 20\n# Encore !\niterators::nextElem(myiter)##  [1] 21 22 23 24 25 26 27 28 29 30\n# Encore ?\niterators::nextElem(myiter)## Error: StopIteration"},{"path":"parallélisation-du-code-r.html","id":"les-autres-plans-de-calculs-parallèle","chapter":"Chapitre 6 Parallélisation du code R","heading":"6.3.2 Les autres “plans” de calculs parallèle","text":"Pour exécuter votre code (exactement le même code, c’est un des avantages\ndu packages de la famille future*), vous devez régler un “plan” de calculs :sur un ordinateur (ou un unique serveur de calcul) sous Unix (Linux, Mac OS),\nvous pouvez utiliser plan(multicore(workers = XX)) qui est souvent plus\nperformant. Le plan multisession fonctionne toujours.sur un ordinateur (ou un unique serveur de calcul) sous Unix (Linux, Mac OS),\nvous pouvez utiliser plan(multicore(workers = XX)) qui est souvent plus\nperformant. Le plan multisession fonctionne toujours.sur un cluster de calculs (type Avakas à Bordeaux), nous renvoyons au package\nfuture.batchtoolssur un cluster de calculs (type Avakas à Bordeaux), nous renvoyons au package\nfuture.batchtools","code":""},{"path":"parallélisation-du-code-r.html","id":"parallélisation-dans-notre-exemple-fil-rouge","chapter":"Chapitre 6 Parallélisation du code R","heading":"6.4 Parallélisation dans notre exemple fil rouge","text":"À vous de jouer !À partir de la fonction mvnpdfoptim() et/ou mvnpdfsmart(), proposez\nune implémentation parallélisant les calculs sur les observations (colonnes de \\(x\\))À partir de la fonction mvnpdfoptim() et/ou mvnpdfsmart(), proposez\nune implémentation parallélisant les calculs sur les observations (colonnes de \\(x\\))Comparez les temps de calcul sur 10 000 observationsComparez les temps de calcul sur 10 000 observationsNotre proposition d’implementation pour mvnpdfoptim_par est téléchargeable ici.","code":"\nplan(multisession(workers = 3))\nn <- 10000\nmb <- microbenchmark::microbenchmark(\n  mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2)),\n  mypkgr::mvnpdfoptim(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n  mypkgr::mvnpdfoptim_par(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE),\n  mypkgr::mvnpdfoptim_parIter(x=matrix(1.96, nrow = 2, ncol = n), Log=FALSE, ncores = 3),\n  times=20L)\nmb## Unit: microseconds\n##                                                                                             expr\n##                                               mvtnorm::dmvnorm(matrix(1.96, nrow = n, ncol = 2))\n##                           mypkgr::mvnpdfoptim(x = matrix(1.96, nrow = 2, ncol = n), Log = FALSE)\n##                  mypkgr::mvnpdfoptim_par(x = matrix(1.96, nrow = 2, ncol = n),      Log = FALSE)\n##  mypkgr::mvnpdfoptim_parIter(x = matrix(1.96, nrow = 2, ncol = n),      Log = FALSE, ncores = 3)\n##        min        lq       mean     median        uq        max neval cld\n##    175.562   215.578   225.8731   223.5525   233.618    280.071    20 a  \n##  13489.041 13781.801 14633.2772 14273.9655 14796.613  18171.692    20 ab \n##  32025.018 32836.592 33700.8233 33300.7740 34809.102  35935.680    20  bc\n##  31920.796 32473.722 45188.2894 33096.4300 34667.591 267307.413    20   c"},{"path":"parallélisation-du-code-r.html","id":"conclusion","chapter":"Chapitre 6 Parallélisation du code R","heading":"6.5 Conclusion","text":"La parallélisation permet de gagner du temps, mais il faut d’abord bien\noptimiser son code. Quand parallélise un code, le gain sur la durée\nd’exécution dépend avant tout du ratio entre le temps de communication et le\ntemps de calcul effectif pour chaque tache.","code":""},{"path":"take-home-message.html","id":"take-home-message","chapter":"Chapitre 7 Take Home message","heading":"Chapitre 7 Take Home message","text":"FAITES DES PACKAGESFAITES DES PACKAGESutilisez git, au moins pour vous en localutilisez git, au moins pour vous en localsi besoin (.e. après optimisation du code R lui même), n’ayez pas peur de vous tourner vers Rcpp et/ou la\nparallélisation de votre codesi besoin (.e. après optimisation du code R lui même), n’ayez pas peur de vous tourner vers Rcpp et/ou la\nparallélisation de votre code","code":""},{"path":"références.html","id":"références","chapter":"Références","heading":"Références","text":"Les livres en ligne d’Hadley Wickham sont vraiment excellents et contiennent\nbeaucoup de compléments par rapport à tout ce que l’traité dans cette\nformation :\nle site sur la construction de package R packages.\nle site Advanced R pour tout ce qui concerne\nl’optimisation, Rcpp, ou encore le calcul parallèle.\nle site R Data Science est également très\ncomplet et comprend des chapitres sur la gestion des structures de données\ndans R, mais aussi la modélisation ainsi que des éléments sur les graphiques et\nRmarkdown.\nLes livres en ligne d’Hadley Wickham sont vraiment excellents et contiennent\nbeaucoup de compléments par rapport à tout ce que l’traité dans cette\nformation :le site sur la construction de package R packages.le site sur la construction de package R packages.le site Advanced R pour tout ce qui concerne\nl’optimisation, Rcpp, ou encore le calcul parallèle.le site Advanced R pour tout ce qui concerne\nl’optimisation, Rcpp, ou encore le calcul parallèle.le site R Data Science est également très\ncomplet et comprend des chapitres sur la gestion des structures de données\ndans R, mais aussi la modélisation ainsi que des éléments sur les graphiques et\nRmarkdown.le site R Data Science est également très\ncomplet et comprend des chapitres sur la gestion des structures de données\ndans R, mais aussi la modélisation ainsi que des éléments sur les graphiques et\nRmarkdown.le livre en ligne Rcpp everyone de\nMasaki E. Tsuda est également très bien.le livre en ligne Rcpp everyone de\nMasaki E. Tsuda est également très bien.","code":""}]
